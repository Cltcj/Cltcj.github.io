<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker容器及使用</title>
      <link href="/2022/09/05/docker-rong-qi-ji-shi-yong/"/>
      <url>/2022/09/05/docker-rong-qi-ji-shi-yong/</url>
      
        <content type="html"><![CDATA[<h3 id="Docker-容器使用"><a href="#Docker-容器使用" class="headerlink" title="Docker 容器使用"></a>Docker 容器使用</h3><hr><h4 id="Docker-客户端"><a href="#Docker-客户端" class="headerlink" title="Docker 客户端"></a>Docker 客户端</h4><p>docker 客户端非常简单 ,我们可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker</code></pre><p><img src="/2022/09/05/docker-rong-qi-ji-shi-yong/image-20220905171048227.png" alt="image-20220905171048227"></p><p>可以通过命令 <strong>docker command –help</strong> 更深入的了解指定的 Docker 命令使用方法。</p><p>例如我们要查看 <strong>docker stats</strong> 指令的具体使用方法：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~# docker stats --help</code></pre><p><img src="/2022/09/05/docker-rong-qi-ji-shi-yong/image-20220905171157824.png" alt="image-20220905171157824"></p><p><img src="/2022/09/05/docker-rong-qi-ji-shi-yong/image-20220905170853523.png" alt="image-20220905170853523"></p><h3 id="容器使用"><a href="#容器使用" class="headerlink" title="容器使用"></a>容器使用</h3><h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><p>如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ docker pull ubuntu</code></pre><p>有的人可能会出现下面问题：</p><p><img src="/2022/09/05/docker-rong-qi-ji-shi-yong/image-20220905171438666.png" alt="image-20220905171438666"></p><p>这是你没有给非root用户权限运行docker，具体参考<a href="https://cltcj.github.io/2022/09/04/docker-jie-shao-ji-an-zhuang/">Docker介绍及安装</a></p><p>当然你也可以直接使用root进行操作：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ sudo docker pull ubuntu</code></pre><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><p>以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ docker run -it ubuntu /bin/bash</code></pre><p>参数说明：</p><ul><li><strong>-i</strong>: 交互式操作。</li><li><strong>-t</strong>: 终端。</li><li><strong>ubuntu</strong>: ubuntu 镜像。</li><li><strong>&#x2F;bin&#x2F;bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash。</li></ul><p>要退出终端，直接输入 <strong>exit</strong>:</p><p>要退出终端，直接输入 <strong>exit</strong>:</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">root@88867067c9dc:/# exit</code></pre><h4 id="启动已止运行的容器"><a href="#启动已止运行的容器" class="headerlink" title="启动已止运行的容器"></a>启动已止运行的容器</h4><p>查看所有的容器命令如下：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ docker ps -a</code></pre><p>使用 docker start 启动一个已停止的容器：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ sudo docker start 88867067c9dc</code></pre><p><img src="/2022/09/05/docker-rong-qi-ji-shi-yong/image-20220905175424186.png" alt="image-20220905175424186"></p><h4 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h4><p>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 <strong>-d</strong> 指定容器的运行模式。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ docker run -itd --name ubuntu-test ubuntu /bin/bash</code></pre><p><strong>注：</strong>加了 <strong>-d</strong> 参数默认不会进入容器，想要进入容器需要使用指令 <strong>docker exec</strong>（下面会介绍到）。</p><h4 id="停止一个容器"><a href="#停止一个容器" class="headerlink" title="停止一个容器"></a>停止一个容器</h4><p>停止容器的命令如下：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ docker stop <容器 ID></code></pre><p>停止的容器可以通过 docker restart 重启：</p><pre><code>$ docker restart &lt;容器 ID&gt;</code></pre><h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><p>在使用 <strong>-d</strong> 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p><ul><li><strong>docker attach</strong></li><li><strong>docker exec</strong>：推荐大家使用 docker exec 命令，因为此命令会退出容器终端，但不会导致容器的停止。</li></ul><p><strong>attach 命令</strong></p><p>下面演示了使用 docker attach 命令。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ sudo docker attach 88867067c9dc</code></pre><p><img src="/2022/09/05/docker-rong-qi-ji-shi-yong/image-20220905175635760.png" alt="image-20220905175635760"></p><p><strong>注意：</strong> 如果从这个容器退出，会导致容器的停止。</p><p><strong>exec 命令</strong></p><p>下面演示了使用 docker exec 命令。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">docker exec -it 88867067c9dc /bin/bash</code></pre><p><strong>注意：</strong> 如果从这个容器退出，容器不会停止，这就是为什么推荐大家使用 <strong>docker exec</strong> 的原因。</p><p>更多参数说明请使用 <strong>docker exec –help</strong> 命令查看。</p><h4 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h4><p><strong>导出容器</strong></p><p>如果要导出本地某个容器，可以使用 <strong>docker export</strong> 命令。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ docker export 88867067c9dc > ubuntu.tar</code></pre><p>导出容器 88867067c9dc 快照到本地文件 ubuntu.tar。</p><p>这样将导出容器快照到本地文件。</p><h4 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a><strong>导入容器快照</strong></h4><p>可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test&#x2F;ubuntu:v1:</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ cat docker/ubuntu.tar | docker import - test/ubuntu:v1</code></pre><p>此外，也可以通过指定 URL 或者某个目录来导入，例如：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ docker import http://example.com/exampleimage.tgz example/imagerepo</code></pre><h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p>删除容器使用 <strong>docker rm</strong> 命令：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ docker rm -f 88867067c9dc</code></pre><p>下面的命令可以清理掉所有处于终止状态的容器。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ docker container prune</code></pre><h3 id="web容器"><a href="#web容器" class="headerlink" title="web容器"></a>web容器</h3><h4 id="运行一个-web-应用"><a href="#运行一个-web-应用" class="headerlink" title="运行一个 web 应用"></a>运行一个 web 应用</h4><p>前面我们运行的容器并没有一些什么特别的用处。</p><p>接下来让我们尝试使用 docker 构建一个 web 应用程序。</p><p>我们将在docker容器中运行一个 Python Flask 应用来运行一个web应用。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker pull training/webapp # 载入镜像clt@clt-virtual-machine:~$ docker run -d -P training/webapp python app.py</code></pre><p><img src="/2022/09/05/docker-rong-qi-ji-shi-yong/image-20220906105844272.png" alt="image-20220906105844272"></p><p>参数说明:</p><ul><li>**-d:**让容器在后台运行。</li><li>**-P:**将容器内部使用的网络端口随机映射到我们使用的主机上。</li></ul><hr><h4 id="查看-WEB-应用容器"><a href="#查看-WEB-应用容器" class="headerlink" title="查看 WEB 应用容器"></a>查看 WEB 应用容器</h4><p>使用 docker ps 来查看我们正在运行的容器：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker psCONTAINER ID   IMAGE             COMMAND           CREATED         STATUS         PORTS                                         NAMES9a31ee6f1f19   training/webapp   "python app.py"   5 minutes ago   Up 4 minutes   0.0.0.0:49153->5000/tcp, :::49153->5000/tcp   affectionate_edisonc781f5452024   ubuntu:15.10      "/bin/bash"       5 minutes ago   Up 5 minutes                                                 compassionate_kirch</code></pre><p>这里多了端口信息。</p><pre><code>PORTS0.0.0.0:49153-&gt;5000/tcp</code></pre><p>Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 49153上。</p><p>这时我们可以通过浏览器访问WEB应用</p><p><img src="/2022/09/05/docker-rong-qi-ji-shi-yong/image-20220906113005395.png" alt="image-20220906113005395"></p><p>我们也可以通过 -p 参数来设置不一样的端口：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker run -d -p 5000:5000 training/webapp python app.py</code></pre><p><strong>docker ps</strong>查看正在运行的容器</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker psCONTAINER ID   IMAGE             COMMAND           CREATED              STATUS              PORTS                                         NAMESa9f76eee97ee   training/webapp   "python app.py"   About a minute ago   Up About a minute   0.0.0.0:5000->5000/tcp, :::5000->5000/tcp     quizzical_kirch9a31ee6f1f19   training/webapp   "python app.py"   35 minutes ago       Up 34 minutes       0.0.0.0:49153->5000/tcp, :::49153->5000/tcp   affectionate_edisonc781f5452024   ubuntu:15.10      "/bin/bash"       35 minutes ago       Up 35 minutes                                                     compassionate_kirch</code></pre><p>容器内部的 5000 端口映射到我们本地主机的 5000 端口上。</p><h4 id="网络端口的快捷方式"><a href="#网络端口的快捷方式" class="headerlink" title="网络端口的快捷方式"></a>网络端口的快捷方式</h4><p>通过 <strong>docker ps</strong> 命令可以查看到容器的端口映射，<strong>docker</strong> 还提供了另一个快捷方式 <strong>docker port</strong>，使用 <strong>docker port</strong> 可以查看指定 （ID 或者名字）容器的某个确定端口映射到宿主机的端口号。</p><p>上面我们创建的 web 应用容器 ID 为 <strong>a9f76eee97ee</strong> 名字为 <strong>quizzical_kirch</strong>。</p><p>我可以使用 <strong>docker port a9f76eee97ee</strong> 或 <strong>docker port quizzical_kirch</strong> 来查看容器端口的映射情况。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker port a9f76eee97ee5000/tcp -> 0.0.0.0:50005000/tcp -> :::5000clt@clt-virtual-machine:~$ docker port quizzical_kirch5000/tcp -> 0.0.0.0:50005000/tcp -> :::5000</code></pre><h4 id="查看-WEB-应用程序日志"><a href="#查看-WEB-应用程序日志" class="headerlink" title="查看 WEB 应用程序日志"></a>查看 WEB 应用程序日志</h4><p>docker logs [ID或者名字] 可以查看容器内部的标准输出。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker logs -f a9f76eee97ee * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)172.17.0.1 - - [06/Sep/2022 03:38:40] "GET / HTTP/1.1" 200 -172.17.0.1 - - [06/Sep/2022 03:38:40] "GET /favicon.ico HTTP/1.1" 404 -</code></pre><p><strong>-f:</strong> 让 <strong>docker logs</strong> 像使用 <strong>tail -f</strong> 一样来输出容器内部的标准输出。</p><p>从上面，我们可以看到应用程序使用的是 5000 端口并且能够查看到应用程序的访问日志。</p><h4 id="查看WEB应用程序容器的进程"><a href="#查看WEB应用程序容器的进程" class="headerlink" title="查看WEB应用程序容器的进程"></a>查看WEB应用程序容器的进程</h4><p>我们还可以使用 docker top 来查看容器内部运行的进程</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker top quizzical_kirchUID                 PID                 PPID                C                   STIME               TTY                 TIME                CMDroot                6059                6037                0                   11:31               ?                   00:00:01            python app.py</code></pre><hr><h4 id="检查-WEB-应用程序"><a href="#检查-WEB-应用程序" class="headerlink" title="检查 WEB 应用程序"></a>检查 WEB 应用程序</h4><p>使用 <strong>docker inspect</strong> 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker inspect quizzical_kirch[    &#123;        "Id": "a9f76eee97ee32e2c6144720f28bc3eee949e0e0ad1caa34d98f0cbb7b83d2ff",        "Created": "2022-09-06T03:31:13.836472995Z",        "Path": "python",        "Args": [            "app.py"        ],        "State": &#123;            "Status": "running",            "Running": true,            "Paused": false,            "Restarting": false,            "OOMKilled": false,            "Dead": false,            "Pid": 6059,            "ExitCode": 0,            "Error": "",            "StartedAt": "2022-09-06T03:31:22.336312232Z",            "FinishedAt": "0001-01-01T00:00:00Z"        &#125;,...</code></pre><h4 id="停止-WEB-应用容器"><a href="#停止-WEB-应用容器" class="headerlink" title="停止 WEB 应用容器"></a>停止 WEB 应用容器</h4><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker stop quizzical_kirch  quizzical_kirch</code></pre><h4 id="重启WEB应用容器"><a href="#重启WEB应用容器" class="headerlink" title="重启WEB应用容器"></a>重启WEB应用容器</h4><p>已经停止的容器，我们可以使用命令 docker start 来启动。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker start quizzical_kirchquizzical_kirch</code></pre><p>docker ps -l 查询最后一次创建的容器：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker ps -l CONTAINER ID   IMAGE             COMMAND           CREATED          STATUS          PORTS                                       NAMESa9f76eee97ee   training/webapp   "python app.py"   10 minutes ago   Up 10 minutes   0.0.0.0:5000->5000/tcp, :::5000->5000/tcp   quizzical_kirch</code></pre><p>正在运行的容器，我们可以使用 <strong>docker restart</strong> 命令来重启。</p><h4 id="移除WEB应用容器"><a href="#移除WEB应用容器" class="headerlink" title="移除WEB应用容器"></a>移除WEB应用容器</h4><p>我们可以使用 docker rm 命令来删除不需要的容器</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker rm quizzical_kirch    quizzical_kirch</code></pre><p>删除容器时，容器必须是停止状态，否则会报如下错误</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker rm quizzical_kirch  Error response from daemon: You cannot remove a running container a9f76eee97ee32e2c6144720f28bc3eee949e0e0ad1caa34d98f0cbb7b83d2ff. Stop the container before attempting removal or force remove</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker介绍及安装</title>
      <link href="/2022/09/04/docker-jie-shao-ji-an-zhuang/"/>
      <url>/2022/09/04/docker-jie-shao-ji-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul><li><p>Docker 是一个开源的应用容器引擎，基于 <a href="https://baike.baidu.com/item/go/953521?fromtitle=Go%E8%AF%AD%E8%A8%80&fromid=3246011&fr=aladdin">Go 语言</a> 并遵从 Apache2.0 协议开源。</p></li><li><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p></li><li><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p></li><li><p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。</p></li><li><p>简单来说：Docker 是一个应用<strong>打包、分发、部署</strong>的工具，你也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要，而普通虚拟机则是一个完整而庞大的系统，包含各种不管你要不要的软件</p><ul><li><p><strong>打包</strong>：就是把你软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包</p></li><li><p><strong>分发</strong>：你可以把你打包好的“安装包”上传到一个镜像仓库，其他人可以非常方便的获取和安装</p></li><li><p><strong>部署</strong>：拿着“安装包”就可以一个命令运行起来你的应用，自动模拟出一摸一样的运行环境，不管是在 Windows&#x2F;Mac&#x2F;Linux。</p></li></ul></li></ul><h3 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h3><ul><li>应用分发、部署，方便传播给他人安装。特别是开源软件和提供私有部署的应用</li><li>应用分发、部署，方便传播给他人安装。特别是开源软件和提供私有部署的应用</li><li>快速安装测试&#x2F;学习软件，用完就丢（类似小程序），不把时间浪费在安装软件上。例如 Redis &#x2F; MongoDB &#x2F; ElasticSearch &#x2F; ELK</li><li>多个版本软件共存，不污染系统，例如 Python2、Python3，Redis4.0，Redis5.0</li></ul><h3 id="Docker-部署的优势"><a href="#Docker-部署的优势" class="headerlink" title="Docker 部署的优势"></a>Docker 部署的优势</h3><p>常规应用开发部署方式：自己在 Windows 上开发、测试 –&gt; 到 Linux 服务器配置运行环境部署。</p><blockquote><p>问题：我机器上跑都没问题，怎么到服务器就各种问题了</p></blockquote><p>用 Docker 开发部署流程：自己在 Windows 上开发、测试 –&gt; 打包为 Docker 镜像（可以理解为软件安装包） –&gt; 各种服务器上只需要一个命令部署好</p><blockquote><p>优点：确保了不同机器上跑都是一致的运行环境，不会出现我机器上跑正常，你机器跑就有问题的情况。</p></blockquote><h3 id="重要概念：镜像、容器"><a href="#重要概念：镜像、容器" class="headerlink" title="重要概念：镜像、容器"></a>重要概念：镜像、容器</h3><p><strong>镜像</strong>：可以理解为软件安装包，可以方便的进行传播和安装。<br><strong>容器</strong>：软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="ubuntu-安装docker"><a href="#ubuntu-安装docker" class="headerlink" title="ubuntu 安装docker"></a>ubuntu 安装docker</h4><p>一、安装docker</p><p>1、安装docker：<code>sudo apt-get install -y docker.io</code></p><p><img src="/2022/09/04/docker-jie-shao-ji-an-zhuang/My_blog/img/image-20220904222102569.png" alt="image-20220904222102569"></p><p>2、启动docker服务：<code>systemctl start docker</code></p><p>3、设置开机启动：<code>systemctl enable docker</code></p><p>4、查看docker状态：<code>systemctl status docker</code></p><p>5、停止docker服务：<code>systemctl stop docker</code></p><p>6、查看docker版本：<code>docker version</code></p><p><img src="/2022/09/04/docker-jie-shao-ji-an-zhuang/My_blog\img\image-20220904222138281.png" alt="image-20220904222138281"></p><p>二、非root用户运行docker</p><p>1、添加docker用户组：<code>sudo groupadd docker</code></p><p>执行以上命令会提示已存在，原因是在安装docker时已自动创建。</p><p>2、将指定用户添加到用户组（username为你的用户名）：<code>sudo gpasswd -a username docker</code></p><p>3、查看是否添加成功：<code>cat /etc/group | grep ^docker</code></p><p>3、重启docker：<code>sudo systemctl restart docker</code></p><p>5、更新用户组：<code>newgrp docker</code></p><p>6、执行docker命令，比如：<code>docker ps -a</code></p><h4 id="windows10"><a href="#windows10" class="headerlink" title="windows10"></a>windows10</h4><p>桌面版：<a href="https://www.docker.com/products/docker-desktop">https://www.docker.com/products/docker-desktop</a><br>服务器版：<a href="https://docs.docker.com/engine/install/#server">https://docs.docker.com/engine/install/#server</a></p><p>安装时出现的错误：</p><p><strong>出现下图错误，点击链接安装最新版本的 WSL2</strong><br><a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi</a></p><p><img src="https://sjwx.easydoc.xyz/46901064/files/kvajwvuw.png" alt="img"></p><h1 id="Docker-镜像加速"><a href="#Docker-镜像加速" class="headerlink" title="Docker 镜像加速"></a>Docker 镜像加速</h1><p>国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：</p><table><thead><tr><th>镜像加速器</th><th>镜像加速器地址</th></tr></thead><tbody><tr><td>Docker 中国官方镜像</td><td><a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></td></tr><tr><td>DaoCloud 镜像站</td><td><a href="http://f1361db2.m.daocloud.io/">http://f1361db2.m.daocloud.io</a></td></tr><tr><td>Azure 中国镜像</td><td><a href="https://dockerhub.azk8s.cn/">https://dockerhub.azk8s.cn</a></td></tr><tr><td>科大镜像站</td><td><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></td></tr><tr><td>阿里云</td><td>https:&#x2F;&#x2F;<your_code>.mirror.aliyuncs.com</your_code></td></tr><tr><td>七牛云</td><td><a href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com</a></td></tr><tr><td>网易云</td><td><a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></td></tr><tr><td>腾讯云</td><td><a href="https://mirror.ccs.tencentyun.com/">https://mirror.ccs.tencentyun.com</a></td></tr></tbody></table><p>当配置某一个加速器地址之后，若发现拉取不到镜像，请切换到另一个加速器地址。国内各大云服务商均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务。</p><p>阿里云镜像获取地址：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors%EF%BC%8C%E7%99%BB%E9%99%86%E5%90%8E%EF%BC%8C%E5%B7%A6%E4%BE%A7%E8%8F%9C%E5%8D%95%E9%80%89%E4%B8%AD%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%99%A8%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%BD%A0%E7%9A%84%E4%B8%93%E5%B1%9E%E5%9C%B0%E5%9D%80%E4%BA%86%EF%BC%9A">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors，登陆后，左侧菜单选中镜像加速器就可以看到你的专属地址了：</a></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/10/02F3AF04-8203-4E3B-A5AF-96973DBE515F.jpg" alt="img"></p><p>对于使用 Windows 10 的系统，在系统右下角托盘 Docker 图标内右键菜单选择 Settings，打开配置窗口后左侧导航菜单选择 Daemon。在 Registrymirrors 一栏中填写加速器地址 <strong><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn/</a></strong> ，之后点击 Apply 保存后 Docker 就会重启并应用配置的镜像地址了。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/10/38507F68-E30F-4CCA-AE9D-9E9EEF60EC83.jpg" alt="img"></p><h3 id="检查加速器是否生效"><a href="#检查加速器是否生效" class="headerlink" title="检查加速器是否生效"></a>检查加速器是否生效</h3><p>检查加速器是否生效配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行 <strong>docker info</strong>，如果从结果中看到了如下内容，说明配置成功。</p><pre class=" language-line-numbers language-cmd"><code class="language-line-numbers language-cmd">$ docker infoRegistry Mirrors:    https://reg-mirror.qiniu.com</code></pre><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>**云服务器(Elastic Compute Service, ECS)**是一种简单高效、安全可靠、处理能力可弹性伸缩的计算服务。</p><p>云服务器管理方式比物理服务器更简单高效，我们无需提前购买昂贵的硬件，即可迅速创建或删除云服务器，云服务器费用一般在几十到几百不等，可以根据我们的需求配置。</p><p>目前市场上的云服务器很多，这里主要介绍以下几家：</p><ul><li><a href="https://www.runoob.com/linux/linux-cloud-server.html#tx">腾讯云</a>：腾讯云目前活动多一些，性价比也高，<a href="https://curl.qcloud.com/tzANIP5i"> <strong>直达链接</strong> </a>。</li><li>更多云服务器参考： <strong><a href="https://c.runoob.com/cloud-server/">https://c.runoob.com/cloud-server/</a></strong></li></ul><blockquote><p><strong>注意：</strong>很多云服务器给新用户提供的优惠力度是最大，基本上都是 1～2 折，建议新注册的用户购买。</p></blockquote><h4 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h4><p><img src="/2022/09/04/docker-jie-shao-ji-an-zhuang/Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220904210025831.png" alt="image-20220904210025831"></p><h3 id="腾讯云服务器使用"><a href="#腾讯云服务器使用" class="headerlink" title="腾讯云服务器使用"></a>腾讯云服务器使用</h3><p>本章节以腾讯云服务器为例。</p><p><strong>1、首先点击下图购买（更多服务器的配置信息见下文）：</strong></p><p><a href="https://curl.qcloud.com/REjETV5p"><img src="https://www.runoob.com/wp-content/uploads/2019/11/ED28C34B-0BF0-4AA3-A95F-2B348B983CEC.jpeg" alt="img"></a></p><p><strong>2、登陆腾讯云控制台，查看已购买的服务器：</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/11/812CFA9E-41F6-4EA2-8044-9FBCAB9C0AAE.jpg" alt="img"></p><p><strong>3、在使用腾讯云服务器前，我们需要先创建一个 SSH 密钥，点击左侧的</strong> <strong>SSH</strong> 密钥（使用密钥登录比密码更安全）：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/11/018E95B9-756E-4B6C-A0A2-CED21B42F25A.jpg" alt="img"></p><p>输入密钥名称，然后点击确定，就会自动生成一个密钥，密钥会自动下载到本地，请保存好下载的密钥，密钥文件名就是你输入的密钥名称。</p><p><strong>4、接着我们勾选已经创建的密钥，点击 *<em>绑定&#x2F;解绑实例*</em> 按钮，弹窗中会出现我们的 ECS 服务器，将其绑定到这个密钥即可：</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/11/963AF776-FE8C-4340-A426-870D962BDC93.jpg" alt="img"></p><p><strong>5、返回实例列表，点击实例右侧的 *<em>登录*</em> 按钮，弹窗中点击立即登录，这是会弹出一个新的浏览器窗口，我们选择密钥登录，密钥文件就是在第三个步骤创建的：</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/11/A23D733A-DA1B-42C9-91E8-12FB84A68400.jpg" alt="img"></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/11/7603BDAC-3103-4379-B0BE-8E669E069AF4.jpg" alt="img"></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/11/D1D8FA9C-4ECD-42A4-B24B-70520F854858.jpg" alt="img"></p><p>当然你可以选择第三方客户端登录（如：SecureCRT），用户名为 ubuntu，其他系统估计略有不同，然后导入对应的 key 即可。</p><p>公众号：写Bug那些事</p><p><a href="https://blog.csdn.net/CltCj?type=blog">我的CSDN</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL 面试常考</title>
      <link href="/2022/09/03/stl-mian-shi-chang-kao/"/>
      <url>/2022/09/03/stl-mian-shi-chang-kao/</url>
      
        <content type="html"><![CDATA[<h4 id="1、请说说-STL-的基本组成部分"><a href="#1、请说说-STL-的基本组成部分" class="headerlink" title="1、请说说 STL 的基本组成部分"></a>1、<strong>请说说 STL 的基本组成部分</strong></h4><ul><li>标准模板库（Standard Template Library,简称STL）简单说，就是一些常用数据结构和算法的模板的集合。广义上讲，STL分为3类：<u>Algorithm（算法）、Container（容器）和Iterator（迭代器）</u>，容器和算法通过迭代器可以进行无缝地连接。详细的说，STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。</li></ul><p><strong>标准模板库STL主要由6大组成部分：</strong></p><p><strong>容器(Container)</strong></p><ul><li>是一种数据结构， 如list, vector, 和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。</li></ul><p><strong>算法（Algorithm）</strong></p><ul><li>是用来操作容器中的数据的模板函数。</li></ul><p><strong>迭代器（Iterator）</strong></p><ul><li>提供了访问容器中对象的方法。</li></ul><p><strong>仿函数（Function object）</strong></p><ul><li>仿函数又称之为函数对象， 其实就是重载了操作符的struct,没有什么特别的地方。</li></ul><p><strong>适配器（Adaptor）</strong></p><ul><li>简单的说就是一种接口类，专门用来修改现有类的接口，提供一中新的接口；或调用现有的函数来实现所需要的功能。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor。</li></ul><p><strong>空间配制器（Allocator）</strong></p><ol><li>为STL提供空间配置的系统。其中主要工作包括两部分：<ol><li>对象的创建与销毁；</li><li>内存的获取与释放。</li></ol></li></ol><h4 id="2、请说说-STL-中常见的容器，并介绍一下实现原理"><a href="#2、请说说-STL-中常见的容器，并介绍一下实现原理" class="headerlink" title="2、请说说 STL 中常见的容器，并介绍一下实现原理"></a>2、<strong>请说说 STL 中常见的容器，并介绍一下实现原理</strong></h4><p>容器可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是模板类，分为顺序容器、关联式容器、容器适配器三种类型，三种类型容器特性分别如下：</p><p>① 顺序容器</p><p>容器并非排序的，元素的插入位置同元素的值无关。包含vector、deque、list，具体实现原理如下：</p><p>（1）vector 头文件</p><p>动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。</p><p>（2）deque 头文件</p><p>双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（仅次于vector）。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。</p><p>（3）list 头文件</p><p>双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。</p><p>② 关联式容器</p><p>元素是排序的；插入任何元素，都按相应的排序规则来确定其位置；在查找时具有非常好的性能；通常以平衡二叉树的方式实现。包含set、multiset、map、multimap，具体实现原理如下：</p><p>（1）set&#x2F;multiset 头文件</p><p>set 即集合。set中不允许相同元素，multiset中允许存在相同元素。</p><p>（2）map&#x2F;multimap 头文件</p><p>map与set的不同在于map中存放的元素有且仅有两个成员变量，一个名为first,另一个名为second, map根据first值对元素从小到大排序，并可快速地根据first来检索元素。</p><p><strong>注意：map和multimap的不同在于是否允许相同first值的元素。</strong></p><p>③ 容器适配器</p><p>封装了一些基本的容器，使之具备了新的函数功能，比如把deque封装一下变为一个具有stack功能的数据结构。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue，具体实现原理如下：</p><p>（1）stack 头文件</p><p>栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最进插入序列的项（栈顶的项）。后进先出。</p><p>（2）queue 头文件</p><p>队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。先进先出。</p><p>（3）priority_queue 头文件</p><p>优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部。最高优先级元素总是第一个出列。</p><h4 id="3、常见容器性质总结？"><a href="#3、常见容器性质总结？" class="headerlink" title="3、常见容器性质总结？"></a>3、<strong>常见容器性质总结？</strong></h4><ol><li>vector 底层数据结构为数组 ，支持快速随机访问</li><li>list 底层数据结构为双向链表，支持快速增删</li><li>deque 底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.它的保存形式如下:[堆1] –&gt; [堆2] –&gt;[堆3] –&gt; …每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.</li><li>stack 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</li><li>queue 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）</li><li>priority_queue 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现</li><li>set 底层数据结构为红黑树，有序，不重复</li><li>multiset 底层数据结构为红黑树，有序，可重复</li><li>map 底层数据结构为红黑树，有序，不重复</li><li>multimap 底层数据结构为红黑树，有序，可重复</li><li>unordered_set 底层数据结构为hash表，无序，不重复</li><li>unordered_multiset 底层数据结构为hash表，无序，可重复</li><li>unordered_map 底层数据结构为hash表，无序，不重复</li><li>unordered_multimap 底层数据结构为hash表，无序，可重复</li></ol><h4 id="4、STL-容器用过哪些，查找的时间复杂度是多少，为什么"><a href="#4、STL-容器用过哪些，查找的时间复杂度是多少，为什么" class="headerlink" title="4、STL 容器用过哪些，查找的时间复杂度是多少，为什么"></a>4、STL 容器用过哪些，查找的时间复杂度是多少，为什么</h4><p>STL中常用的容器有vector、deque、list、map、set、multimap、multiset、unordered_map、unordered_set等。容器底层实现方式及时间复杂度分别如下：</p><ol><li>vector：采用一维数组实现，元素在内存连续存放，不同操作的时间复杂度为：</li></ol><ul><li>插入: O(N)</li><li>查看: O(1)</li><li>删除: O(N)</li></ul><ol start="2"><li>deque：采用双向队列实现，元素在内存连续存放，不同操作的时间复杂度为：</li></ol><ul><li>插入: O(N)</li><li>查看: O(1)删除: O(N)</li></ul><ol start="3"><li>list：采用双向链表实现，元素存放在堆中，不同操作的时间复杂度为：</li></ol><ul><li>插入: O(1)</li><li>查看: O(N)</li><li>删除: O(1)</li></ul><ol start="4"><li>map、set、multimap、multiset：这四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为:</li></ol><ul><li>插入: O(logN)</li><li>查看: O(logN)</li><li>删除: O(logN)</li></ul><h4 id="5、说一下STL每种容器对应的迭代器"><a href="#5、说一下STL每种容器对应的迭代器" class="headerlink" title="5、说一下STL每种容器对应的迭代器"></a>5、<strong>说一下STL每种容器对应的迭代器</strong></h4><ul><li>随机访问迭代器：vector、deque</li><li>双向迭代器：list、(multi)set&#x2F;map</li><li>前向迭代器：unordered_(multi)set&#x2F;map、forward_list</li></ul><h4 id="6、STL中vector的实现"><a href="#6、STL中vector的实现" class="headerlink" title="6、STL中vector的实现"></a>6、<strong>STL中vector的实现</strong></h4><ul><li>vector是一种序列式容器，其数据安排以及操作方式与array非常类似，两者的唯一差别就是对于空间运用的灵活性，众所周知，array占用的是静态空间，一旦配置了就不可以改变大小，如果遇到空间不足的情况还要自行创建更大的空间，并手动将数据拷贝到新的空间中，再把原来的空间释放。vector则使用灵活的动态空间配置，维护一块连续的线性空间，在空间不足时，可以自动扩展空间容纳新元素，做到按需供给。其在扩充空间的过程中仍然需要经历：重新配置空间，移动数据，释放原空间等操作。这里需要说明一下动态扩容的规则：以原大小的两倍配置另外一块较大的空间（或者旧长度+新增元素的个数）vector扩容倍数与平台有关，在Win + VS 下是 1.5倍，在 Linux + GCC 下是 2 倍需要注意的是，频繁对vector调用push_back()对性能是有影响的，这是因为每插入一个元素，如果空间够用的话还能直接插入，若空间不够用，则需要重新配置空间，移动数据，释放原空间等操作，对程序性能会造成一定的影响。</li></ul><h4 id="7、简述-vector-的实现原理"><a href="#7、简述-vector-的实现原理" class="headerlink" title="7、简述 vector 的实现原理"></a>7、<strong>简述 vector 的实现原理</strong></h4><p>vector底层实现原理为一维数组（元素在空间连续存放）。</p><ol><li><p>新增元素</p><ul><li>vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。插入新的数据分在最后插入push_back和通过迭代器在任何位置插入，这里说一下通过迭代器插入，通过迭代器与第一个元素的距离知道要插入的位置，即int index&#x3D;iter-begin()。这个元素后面的所有元素都向后移动一个位置，在空出来的位置上存入新增的元素。</li></ul></li><li><p>删除元素</p><ul><li>删除和新增差不多，也分两种，删除最后一个元素pop_back和通过迭代器删除任意一个元素erase(iter)。通过迭代器删除还是先找到要删除元素的位置，即int index&#x3D;iter-begin();这个位置后面的每个元素都想前移动一个元素的位置。同时我们知道erase不释放内存只初始化成默认值。删除全部元素clear：只是循环调用了erase，所以删除全部元素的时候，不释放内存。内存是在析构函数中释放的。</li></ul></li><li><p>迭代器iteraotr</p><ul><li>迭代器iteraotr是STL的一个重要组成部分,通过iterator可以很方便的存储集合中的元素.STL为每个集合都写了一个迭代器, 迭代器其实是对一个指针的包装,实现一些常用的方法,如++,–,!&#x3D;,&#x3D;&#x3D;,*,-&gt;等,通过这些方法可以找到当前元素或是别的元素. vector是STL集合中比较特殊的一个,因为vector中的每个元素都是连续的,所以在自己实现vector的时候可以用指针代替。</li></ul></li></ol><h4 id="8、STL-中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"><a href="#8、STL-中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？" class="headerlink" title="8、STL 中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"></a>8、<strong>STL 中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？</strong></h4><ul><li><p>size()函数返回的是已用空间大小，capacity()返回的是总空间大小，capacity()-size()则是剩余的可用空间大小。当size()和capacity()相等，说明vector目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长。</p></li><li><p>由于动态增长会引起重新分配内存空间、拷贝原空间、释放原空间，这些过程会降低程序效率。因此，可以使用reserve(n)预先分配一块较大的指定大小的内存空间，这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的，这样便提升了效率。只有当n&gt;capacity()时，调用reserve(n)才会改变vector容量。</p></li><li><p>resize()成员函数改变元素的数目，至于空间的的变化需要看具体情况去分析，如下：</p><ol><li>空的vector对象，size()和capacity()都为0</li><li>当空间大小不足时，新分配的空间大小为原空间大小的2倍。</li><li>使用reserve()预先分配一块内存后，在空间未满的情况下，不会引起重新分配，从而提升了效率。</li><li>当reserve()分配的空间比原空间小时，是不会引起重新分配的。</li><li>resize()函数只改变容器的元素数目，未改变容器大小。</li><li>用reserve(size_type)只是扩大capacity值，这些内存空间可能还是“野”的，如果此时使用“[ ]”来访问，则可能会越界。而resize(size_type new_size)会真正使容器具有new_size个对象。</li></ol></li><li><p>不同的编译器，vector有不同的扩容大小。在vs下是1.5倍，在GCC下是2倍；</p></li><li><p>空间和时间的权衡。简单来说， 空间分配的多，平摊时间复杂度低，但浪费空间也多。</p></li><li><p>使用k&#x3D;2增长因子的问题在于，每次扩展的新尺寸必然刚好大于之前分配的总和，也就是说，之前分配的内存空间不可能被使用。这样对内存不友好，最好把增长因子设为(1, 2)，也就是1-2之间的某个数值。对比可以发现<em><strong>*采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。*</strong></em></p></li></ul><h4 id="9、vector如何释放空间"><a href="#9、vector如何释放空间" class="headerlink" title="9、vector如何释放空间?"></a>9、<strong>vector如何释放空间?</strong></h4><ul><li><p>由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。</p></li><li><p>如果需要空间动态缩小，可以考虑使用deque。如果vector，可以用swap()来帮助你释放内存。</p></li></ul><h4 id="10、vector的增加删除都是怎么做的？"><a href="#10、vector的增加删除都是怎么做的？" class="headerlink" title="10、vector的增加删除都是怎么做的？"></a>10、vector的增加删除都是怎么做的？</h4><p>① 新增元素：vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；</p><p>② 对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了 ；</p><p>③ 初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1；</p><p>④ 不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。</p><p>对比可以发现采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容</p><h4 id="11、STL中list的实现"><a href="#11、STL中list的实现" class="headerlink" title="11、STL中list的实现"></a>11、<strong>STL中list的实现</strong></h4><ul><li>相比于vector的连续线型空间，list显得复杂许多，但是它的好处在于插入或删除都只作用于一个元素空间，因此list对空间的运用是十分精准的，对任何位置元素的插入和删除都是常数时间。list不能保证节点在存储空间中连续存储，也拥有迭代器，迭代器的“++”、“–”操作对于的是指针的操作，list提供的迭代器类型是双向迭代器：Bidirectional iterators。</li><li>list是一个双向链表。list与vector的另一个区别是，在插入和接合操作之后，都不会造成原迭代器失效，而vector可能因为空间重新配置导致迭代器失效。</li><li>list也是一个环形链表，因此只要一个指针便能完整表现整个链表。list中node节点指针始终指向尾端的一个空白节点，因此是一种“前闭后开”的区间结构</li><li>list的空间管理默认采用alloc作为空间配置器，<strong>为了方便的以节点大小为配置单位，还定义一个list_node_allocator函数可一次性配置多个节点空间。</strong></li></ul><h4 id="11、STL中list的实现-1"><a href="#11、STL中list的实现-1" class="headerlink" title="11、STL中list的实现"></a>11、<strong>STL中list的实现</strong></h4><ul><li>相比于vector的连续线型空间，list显得复杂许多，但是它的好处在于插入或删除都只作用于一个元素空间，因此list对空间的运用是十分精准的，对任何位置元素的插入和删除都是常数时间。list不能保证节点在存储空间中连续存储，也拥有迭代器，迭代器的“++”、“–”操作对于的是指针的操作，list提供的迭代器类型是双向迭代器：Bidirectional iterators。</li></ul><p>list节点的结构见如下源码：</p><p>template <class t></class></p><p>struct __list_node{</p><p>  typedef void* void_pointer;</p><p>  void_pointer prev;</p><p>  void_pointer next;</p><p>  T data;</p><p>}</p><p>从源码可看出list显然是一个双向链表。list与vector的另一个区别是，在插入和接合操作之后，都不会造成原迭代器失效，而vector可能因为空间重新配置导致迭代器</p><h4 id="12、STL中迭代器失效的情况有哪些？"><a href="#12、STL中迭代器失效的情况有哪些？" class="headerlink" title="12、STL中迭代器失效的情况有哪些？"></a>12、<strong>STL中迭代器失效的情况有哪些？</strong></h4><p><strong>vector：</strong></p><ul><li><p><strong>插入元素：</strong></p><ul><li>1、尾后插入：size &lt; capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size &#x3D;&#x3D; capacity时，所有迭代器均失效（需要重新分配空间）。</li><li>2、中间插入：中间插入：size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size &#x3D;&#x3D; capacity时，所有迭代器均失效。</li></ul></li><li><p>删除元素：</p><ul><li>尾后删除：只有尾迭代失效。</li><li>中间删除：删除位置之后所有迭代失效。</li></ul></li></ul><p><strong>deque 和 vector 的情况类似</strong></p><p>而 list 双向链表每一个节点内存不连续, 删除节点仅当前迭代器失效,erase返回下一个有效迭代器;</p><p>map&#x2F;se t等关联容器底层是红黑树删除节点不会影响其他节点的迭代器, 使用递增方法获取下一个迭代器 mmp.erase(iter++);</p><p>unordered_(hash)  迭代器意义不大, rehash 之后, 迭代器应该也是全部失效.</p><h4 id="13、说说-vector-和-list-的区别，分别适用于什么场景？"><a href="#13、说说-vector-和-list-的区别，分别适用于什么场景？" class="headerlink" title="13、说说 vector 和 list 的区别，分别适用于什么场景？"></a>13、<strong>说说 vector</strong> 和 list 的区别，分别适用于什么场景？</h4><p><u>vector和list区别在于底层实现机理不同，因而特性和适用场景也有所不同。</u> </p><p><strong>vector：一维数组</strong></p><ul><li>特点：元素在内存连续存放，动态数组，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后内存也不会释放。 </li><li>优点：和数组类似开辟一段连续的空间，并且支持随机访问，所以它的查找效率高其时间复杂度 O(1)。 </li><li>缺点：由于开辟一段连续的空间，所以插入删除会需要对数据进行移动比较麻烦，时间复杂度 O（n），另外当空间不足时还需要进行扩容。</li></ul><p><strong>list：双向链表</strong> </p><ul><li>特点：元素在堆中存放，每个元素都是存放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问。 </li><li>优点：底层实现是循环双链表，当对大量数据进行插入删除时，其时间复杂度O(1)。 </li><li>缺点：底层没有连续的空间，只能通过指针来访问，所以查找数据需要遍历其时间复杂度O（n）， 没有提供[]操作符的重载。</li></ul><p><strong>应用场景</strong> </p><ul><li>vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随机访问，而不在乎插入和删除的效率，使用vector。 </li><li>list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。</li></ul><h4 id="14、C-的-vector-和-list中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？"><a href="#14、C-的-vector-和-list中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？" class="headerlink" title="14、C++ 的 vector 和 list中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？"></a>14、<strong>C++ 的 vector 和 list中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？</strong></h4><ol><li><p>迭代器和指针之间的区别</p><ul><li>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，重载了指针的一些操作符，–&gt;、++、–等。迭代器封装了指针，是一个”可遍历STL（ Standard TemplateLibrary）容器内全部或部分元素”的对象，本质是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</li><li>迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。</li></ul></li><li><p>vector和list特性</p><ul><li>vector特性 动态数组。元素在内存连续存放。随机存取任何元素都在常数时间完成。在尾端增删元素具有较大的性能（大部分情况下是常数时间）。</li><li>list特性 双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。</li></ul></li><li><p>vector增删元素</p><ul><li>对于vector而言，删除某个元素以后，该元素后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。</li></ul></li><li><p>list增删元素</p><ul><li>对于list而言，删除某个元素，只有“指向被删除元素”的那个迭代器失效，其它迭代器不受任何影响。</li></ul></li></ol><h4 id="15、STL-中-vector-与-list-具体是怎么实现的？常见操作的时间复杂度是多少？"><a href="#15、STL-中-vector-与-list-具体是怎么实现的？常见操作的时间复杂度是多少？" class="headerlink" title="15、STL 中 vector 与 list 具体是怎么实现的？常见操作的时间复杂度是多少？"></a>15、<strong>STL</strong> <strong>中</strong> <strong>vector</strong> <strong>与 list 具体是怎么实现的？常见操作的时间复杂度是多少？</strong></h4><ol><li><p>vector （元素在内存连续存放）</p><ul><li>vector是动态数组，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后，内存也不会释放；如果新增大小当前大小时才会重新分配内存。</li></ul></li><li><p>list 双向链表（元素存放在堆中）</p><ul><li>元素存放在堆中，每个元素都是放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点，使得它的**随机存取变得非常没有效率*<em><strong>，因此它没有提供[ ]操作符的重载。但是由于链表的特点，</strong>它可以很有效的支持任意地方的删除和插入操作。</em>*</li><li>*特点：**a. 随机访问不方便 b. 删除插入操作方便</li></ul></li><li><p>常见时间复杂度</p><ul><li>vector插入、查找、删除时间复杂度分别为：O(n)、O(1)、O(n)； </li><li>list插入、查找、删除时间复杂度分别为：O(1)、O(n)O(1)。</li></ul></li></ol><h4 id="16、简述-STL-中的-map-的实现原理"><a href="#16、简述-STL-中的-map-的实现原理" class="headerlink" title="16、简述 STL 中的 map 的实现原理"></a>16、<strong>简述 STL 中的 map 的实现原理</strong></h4><ul><li><p>map是关联式容器，map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。</p></li><li><p>map内部实现了一个红黑树（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。map的特性是所有元素会根据键值进行自动排序。map中所有的元素都是pair，拥有键值(key)和实值(value)两个部分，并且不允许元素有相同的key。</p></li><li><p><u>一旦map的key确定了，那么是无法修改的，但是可以修改这个key对应的value</u>。</p></li><li><p>map的在构造时缺省采用递增排序key，也使用alloc配置器配置空间大小，需要注意的是在插入元素时，调用的是红黑树中的insert_unique()方法，而非insert_euqal()（multimap使用）</p></li><li><p><strong>map的特性如下</strong></p><ol><li>map以RBTree作为底层容器；</li><li>所有元素都是键+值存在；</li><li>不允许键重复所有元素是通过键进行自动排序的；</li><li>map的键是不能修改的，但是其键对应的值是可以修改的。</li></ol></li><li><p><strong>红黑树的特性：</strong></p><ul><li>每个节点不是红色就是黑色</li><li>根结点为黑色</li><li>如果节点为红色，其子节点必为黑</li><li><strong>任一节点至（NULL）树尾端的任何路径，所含的黑节点数量必相同</strong></li></ul></li></ul><h4 id="17、STL中set的实现？"><a href="#17、STL中set的实现？" class="headerlink" title="17、STL中set的实现？"></a>17、<strong>STL中set的实现？</strong></h4><ul><li>STL中的容器可分为序列式容器（sequence）和关联式容器（associative），set属于关联式容器。</li><li>set的特性是，所有元素都会根据元素的值自动被排序（默认升序），set元素的键值就是实值，实值就是键值，set不允许有两个相同的键值。</li><li>set不允许迭代器修改元素的值，其迭代器是一种constance iterators。</li><li>标准的STL set以RB-tree（红黑树）作为底层机制，几乎所有的set操作行为都是转调用RB-tree的操作行为。</li></ul><h4 id="18、请你来说一下-map-和-set-有什么区别，分别又是怎么实现的？"><a href="#18、请你来说一下-map-和-set-有什么区别，分别又是怎么实现的？" class="headerlink" title="18、请你来说一下 map 和 set 有什么区别，分别又是怎么实现的？"></a>18、<strong>请你来说一下 map 和 set 有什么区别，分别又是怎么实现的？</strong></h4><ol><li>set是一种关联式容器，其特性如下：<ul><li>set以RBTree作为底层容器</li><li>所得元素的只有key没有value，value就是key </li><li>不允许出现键值重复</li><li>所有的元素都会被自动排序</li><li>不能通过迭代器来改变set的值，因为set的值就是键，set的迭代器是const的</li></ul></li><li>map和set一样是关联式容器，其特性如下：<ol><li>map以RBTree作为底层容器</li><li>所有元素都是键+值存在</li><li>不允许键重复</li><li>所有元素是通过键进行自动排序的</li><li>map的键是不能修改的，但是其键对应的值是可以修改的</li></ol></li></ol><h4 id="19、STL中的deque的实现"><a href="#19、STL中的deque的实现" class="headerlink" title="19、STL中的deque的实现"></a>19、<strong>STL中的deque的实现</strong></h4><ul><li>vector是单向开口（尾部）的连续线性空间，deque则是一种双向开口的连续线性空间，虽然vector也可以在头尾进行元素操作，但是其头部操作的效率十分低下（主要是涉及到整体的移动）</li></ul><p><img src="https://img2020.cnblogs.com/blog/1657559/202107/1657559-20210728211357818-746549817.png" alt="img"></p><ul><li>deque和vector的最大差异一个是deque运行在常数时间内对头端进行元素操作，二是deque没有容量的概念，它是动态地以分段连续空间组合而成，可以随时增加一段新的空间并链接起来。</li><li>deque虽然也提供随机访问的迭代器，但是其迭代器并不是普通的指针，其复杂程度比vector高很多，因此除非必要，否则一般使用vector而非deque。如果需要对deque排序，可以先将deque中的元素复制到vector中，利用sort对vector排序，再将结果复制回deque</li><li>deque由一段一段的定量连续空间组成，一旦需要增加新的空间，只要配置一段定量连续空间拼接在头部或尾部即可，因此deque的最大任务是如何维护这个整体的连续性</li><li>deque的数据结构如下：</li></ul><p><img src="https://img2020.cnblogs.com/blog/1657559/202107/1657559-20210728212220991-1931832786.png" alt="img"></p><ul><li>从deque的迭代器数据结构可以看出，为了保持与容器联结，迭代器主要包含上述4个元素</li><li>deque迭代器的“++”、“–”操作是远比vector迭代器繁琐，其主要工作在于缓冲区边界，如何从当前缓冲 区跳到另一个缓冲区，当然deque内部在插入元素时，如果map中node数量全部使用完，且node指向的缓 冲区也没有多余的空间，这时会配置新的map（2倍于当前+2的数量）来容纳更多的node，也就是可以指 向更多的缓冲区。在deque删除元素时，也提供了元素的析构和空闲缓冲区空间的释放等机制。</li></ul><h4 id="20、STL中hashtable的实现？"><a href="#20、STL中hashtable的实现？" class="headerlink" title="20、STL中hashtable的实现？"></a>20、<strong>STL中</strong>hashtable的实现？</h4><ul><li>STL中的hashtable，使用vector作为底层容器来构建一个bucket(桶)的聚合体，每一个桶维护一个链表来存储元素。能够设计一个哈希函数，使得每一个元素的关键字与一个值一一对应。</li><li>hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作</li><li>在hashtable设计bucket的数量上，其内置了28个质数[53, 97, 193,…,429496729]，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度），其中每个bucket所维护的linked-list长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置。</li></ul><h4 id="21、STL中stack和queue的实现"><a href="#21、STL中stack和queue的实现" class="headerlink" title="21、STL中stack和queue的实现"></a>21、<strong>STL中stack和queue的实现</strong></h4><p><strong>stack</strong></p><ul><li>stack（栈）是一种先进后出（First In Last Out）的数据结构，只有一个入口和出口，那就是栈顶，除了获取栈顶元素外，没有其他方法可以获取到内部的其他元素，其结构图如下：</li></ul><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml8644\wps8.jpg" alt="img"> </p><ul><li><p>stack这种单向开口的数据结构很容易由双向开口的deque和list形成，只需要根据stack的性质对应移除某些接口即可实现。</p></li><li><p>stack除了默认使用deque作为其底层容器之外，也可以使用双向开口的list，只需要在初始化stack时，将list作为第二个参数即可。由于stack只能操作顶端的元素，因此其内部元素无法被访问，也不提供迭代器。</p></li></ul><p><strong>queue</strong></p><ul><li>queue（队列）是一种先进先出（First In First Out）的数据结构，只有一个入口和一个出口，分别位于最底端和最顶端，出口元素外，没有其他方法可以获取到内部的其他元素，其结构图如下：</li></ul><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml8644\wps9.jpg" alt="img"> </p><ul><li>类似的，queue这种“先进先出”的数据结构很容易由双向开口的deque和list形成，只需要根据queue的性质对应移除某些接口即可实现，同样，queue也可以使用list作为底层容器，不具有遍历功能，没有迭代器。</li></ul><h4 id="22、说说-STL-中-map-hashtable-deque-list-的实现原理"><a href="#22、说说-STL-中-map-hashtable-deque-list-的实现原理" class="headerlink" title="22、说说 STL 中 map hashtable deque list 的实现原理"></a>22、<strong>说说 STL</strong> <strong>中 map</strong> <strong>hashtable deque list 的实现原理</strong></h4><p>map、hashtable、deque、list实现机理分别为红黑树、函数映射、双向队列、双向链表，他们的特性分别如下：</p><ol><li><p><strong>map实现原理</strong></p><ul><li>map内部实现了一个红黑树（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。</li></ul></li><li><p><strong>hashtable（也称散列表，直译作哈希表）实现原理</strong></p><ul><li>hashtable采用了函数映射的思想记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。这决定了哈希表特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。</li></ul></li><li><p><strong>deque实现原理</strong></p><ul><li>deque内部实现的是一个双向队列。元素在内存连续存放。随机存取任何元素都在常数时间完成（仅次于vector）。所有适用于vector的操作都适用于deque。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。</li></ul></li><li><p><strong>list实现原理</strong></p><ul><li>list内部实现的是一个双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。无成员函数，给定一个下标i，访问第i个元素的内容，只能从头部挨个遍历到第i个元素。</li></ul></li></ol><h4 id="23、STL中的priority-queue的实现"><a href="#23、STL中的priority-queue的实现" class="headerlink" title="23、STL中的priority_queue的实现"></a>23、<strong>STL中的priority_queue的实现</strong></h4><ul><li>priority_queue，优先队列，是一个拥有权值观念的queue，它跟queue一样是顶部入口，底部出口，在插入元素时，元素并非按照插入次序排列，它会自动根据权值（通常是元素的实值）排列，权值最高，排在最前面，如下图所示。</li></ul><p>​<img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml8644\wps10.jpg" alt="img"> </p><ul><li>默认情况下，priority_queue使用一个max-heap完成，底层容器使用的是一般为vector为底层容器，堆heap为处理规则来管理底层容器实现 。priority_queue的这种实现机制导致其不被归为容器，而是一种容器配接器。</li><li>priority_queue的所有元素，进出都有一定的规则，只有queue顶端的元素（权值最高者），才有机会被外界取用，它没有遍历功能，也不提供迭代器</li></ul><h4 id="24、map插入方式？"><a href="#24、map插入方式？" class="headerlink" title="24、map插入方式？"></a>24、<strong>map</strong>插入方式？</h4><p>① 用insert函数插入pair数据</p><p><code>mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_one&quot;));</code> </p><p>② 用insert函数插入value_type数据</p><p><code>mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;));</code></p><p>③ 在insert函数中使用make_pair()函数</p><p><code>mapStudent.insert(make_pair(1, &quot;student_one&quot;));</code> </p><p>④ 用数组方式插入数据</p><p><code>mapStudent[1] = &quot;student_one&quot;;</code> </p><h4 id="25、STL中unordered-map-hash-map-和map的区别，hash-map如何解决冲突以及扩容"><a href="#25、STL中unordered-map-hash-map-和map的区别，hash-map如何解决冲突以及扩容" class="headerlink" title="25、STL中unordered**_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容 **"></a>25、<strong>STL中</strong>unordered**_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容 **</h4><ol><li>unordered_map和map类似，都是存储的key-value的值，可以通过key快速索引到value。不同的是unordered_map不会根据key的大小进行排序。</li><li>存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的，而map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。</li><li>所以使用时map的key需要定义operator&lt;。而unordered_map需要定义hash_value函数并且重载operator&#x3D;&#x3D;。但是很多系统内置的数据类型都自带这些。</li><li>那么如果是自定义类型，那么就需要自己重载operator&lt;或者hash_value()了。</li><li>如果需要内部元素自动排序，使用map，不需要排序使用unordered_map</li><li>unordered_map的底层实现是hash_table;</li><li>hash_map底层使用的是hash_table，而hash_table使用的开链法进行冲突避免，所有hash_map采用开链法进行冲突解决。</li><li><strong>什么时候扩容：</strong>当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值—即当前数组的长度乘以加载因子的值的时候，就要自动扩容。</li><li>**扩容(resize)**就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。</li></ol><h4 id="26、STL中unordered-map和map的区别和应用场景"><a href="#26、STL中unordered-map和map的区别和应用场景" class="headerlink" title="26、STL中unordered_map和map的区别和应用场景"></a>26、<strong>STL中unordered_map和map的区别和应用场景</strong></h4><ul><li>map支持键值的自动排序，底层机制是红黑树，红黑树的查询和维护时间复杂度均为O(log(n))，但是空间占用比较大，因为每个节点要保持父节点、孩子节点及颜色的信息。</li><li>Unordered_map是C++11新添加的容器，底层机制是哈希表，通过hash函数计算元素位置，其查询时间复杂度O(1)，维护时间和bucket桶所维护的list长度有关，但是建立hash表耗时大。</li><li>从两者底层实现来看，map适用于有序数据的应用场景，unordered_map适用于高效查询的应用场。</li></ul><h4 id="27、说说-map-和-unordered-map-的区别？底层实现"><a href="#27、说说-map-和-unordered-map-的区别？底层实现" class="headerlink" title="27、说说 map 和 unordered_map 的区别？底层实现"></a>27、说说 map 和 unordered_map 的区别？底层实现</h4><ul><li>map和unordered_map的区别在于他们的实现基理不同。</li></ul><ol><li><p>map实现机理</p><ul><li>map内部实现了一个红黑树（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。</li></ul></li><li><p>unordered_map实现机理</p><ul><li>unordered_map内部实现了一个哈希表（也叫散列表），通过把关键码值映射到Hash表中一个位置来访问记录，查找时间复杂度可达O（1），其中在海量数据处理中有着广泛应用。因此，元素的排列顺序是无序的。</li></ul></li></ol><h4 id="28、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"><a href="#28、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？" class="headerlink" title="28、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"></a>28、<strong>vector越界</strong>访问<strong>下标，map越界访问下标？vector删除元素时会不会释放空间？</strong></h4><ul><li><p>① 通过下标访问vector中的元素时会做边界检查，但该处的实现方式要看具体IDE，不同IDE的实现方式不一样，确保不可访问越界地址。</p></li><li><p>② map的下标运算符[]的作用是：将key作为下标去执行查找，并返回相应的值；如果不存在这个key，就将一个具有该key和value的某值插入这个map。</p></li><li><p>③ erase()函数，只能删除内容，不能改变容量大小;</p></li><li><p>④ erase成员函数，它删除了itVect迭代器指向的元素，并且返回要被删除的itVect之后的迭代器，迭代器相当于一个智能指针;</p></li><li><p>⑤ clear()函数，只能清空内容，不能改变容量大小;如果要想在删除内容的同时释放内存，那么你可以选择deque容器。</p></li></ul><h4 id="29、map中-与find的区别？"><a href="#29、map中-与find的区别？" class="headerlink" title="29、map中[]与find的区别？"></a>29、<strong>map中[]与find的区别？</strong></h4><ul><li>map的下标运算符[]的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map。</li><li>map的find函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。</li></ul><h4 id="30、STL中list与queue之间的区别"><a href="#30、STL中list与queue之间的区别" class="headerlink" title="30、STL中list与queue之间的区别"></a>30、<strong>STL中list与queue之间的区别</strong></h4><ul><li>① list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在存储空间中连续存在；</li><li>②list插入操作和接合操作都不会造成原有的list迭代器失效;</li><li>③ list不仅是一个双向链表，而且还是一个环状双向链表，所以它只需要一个指针；</li><li>④ list不像vector那样有可能在空间不足时做重新配置、数据移动的操作，所以插入前的所有迭代器在插入操作之后都仍然有效；</li><li>⑤ deque是一种双向开口的连续线性空间，所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作；</li><li>⑥ deque和vector最大的差异，一在于deque允许常数时间内对起头端进行元素的插入或移除操作，二在于deque没有所谓容量概念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，deque没有所谓的空间保留功能。</li></ul><h4 id="31、set和map的区别，multimap和multiset区别"><a href="#31、set和map的区别，multimap和multiset区别" class="headerlink" title="31、set和map的区别，multimap和multiset区别"></a>31、<strong>set和map的区别，multimap和multiset区别</strong></h4><ul><li>set只提供一种数据类型的接口，但是它会将这一个元素分配到key和value上，而且它的compare_function用的是identity函数，这个函数是输入什么就输出什么，这样就实现了set机制，set的key和value是一样的，它保存的是两份数据，而不是一份数据</li><li>map提供了两种数据类型的接口，分别分配到key和value上，它的compare_function采用的是红黑树的compare_function，它保存的是两份数据</li><li>它们两个的insert都是红黑树的insert_unique()独一无二的插入</li><li>multimap和map唯一的区别就是：multimap调用的是insert_equal()可以重复插入，map调用的是独一无二的插入，set和multiset也一样，只是再插入的时候调用的方法不一样，底层实现都一样。</li></ul><h4 id="32、hashtable中解决冲突的方法？"><a href="#32、hashtable中解决冲突的方法？" class="headerlink" title="32、hashtable中解决冲突的方法？"></a>32、<strong>hashtable中解决冲突的方法？</strong></h4><p><strong>开链法</strong>：每个桶维护一条list，如果哈希函数计算出的桶相同，则按顺序存在这个list中。</p><p><strong>再散列</strong>：发生冲突时使用另一种哈希函数再计算一个地址，直到不冲突</p><p><strong>线性探测</strong>：使用哈希函数计算出的位置如果已经由元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位。</p><p><strong>二次探测</strong>：使用hash函数计算出的位置如果已经有元素占用了，按照1^2、2^2、3^2…的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测</p><p><strong>公共溢出区</strong>：一旦hash函数计算的结果相同，就放入公共溢出区</p><h4 id="33、容器内部删除一个元素"><a href="#33、容器内部删除一个元素" class="headerlink" title="33、容器内部删除一个元素"></a>33、<strong>容器内部删除一个元素</strong></h4><ul><li>① 顺序容器（序列式容器，比如vector、deque）<ul><li>erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；</li></ul></li><li>② 关联容器(关联式容器，比如map、set、multimap、multiset等)<ul><li>erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；</li></ul></li></ul><h4 id="34、STL中hash-map扩容发生什么？"><a href="#34、STL中hash-map扩容发生什么？" class="headerlink" title="34、STL中hash_map扩容发生什么？"></a>34、STL中hash_map扩容发生什么？</h4><ol><li>hash table表格内的元素称为桶（bucket),而由桶所链接的元素称为节点（node),其中存入桶元素的容器为stl本身很重要的一种序列式容器——vector容器。之所以选择vector为存放桶元素的基础容器，主要是因为vector容器本身具有动态扩容能力，无需人工干预。</li><li>向前操作：首先尝试从目前所指的节点出发，前进一个位置（节点），由于节点被安置于list内，所以利用节点的next指针即可轻易完成前进操作，如果目前正巧是list的尾端，就跳至下一个bucket身上，那正是指向下一个list的头部节点。</li></ol><h4 id="35、STL迭代器讲一下"><a href="#35、STL迭代器讲一下" class="headerlink" title="35、STL迭代器讲一下"></a>35、<strong>STL迭代器讲一下</strong></h4><ol><li>Iterator（迭代器）模式又称游标（Cursor）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。 由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展Iterator。</li><li>迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。</li><li>迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的是*运算符与-&gt;运算符，以及++、–等可能需要重载的运算符重载。这和C++中的智能指针很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能。</li><li>最常用的迭代器的相应型别有五种：value type、difference type、pointer、reference、iterator catagoly;</li></ol><h4 id="36、迭代器用过吗？什么时候会失效？"><a href="#36、迭代器用过吗？什么时候会失效？" class="headerlink" title="36、迭代器用过吗？什么时候会失效？"></a>36、<strong>迭代器用过吗？什么时候会失效？</strong></h4><p>用过，常用容器迭代器失效情形如下:</p><ol><li><p>对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。</p></li><li><p>对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。</p></li><li><p>对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。</p></li></ol><h4 id="37、说一下STL中迭代器的作用，有指针为何还要迭代器？"><a href="#37、说一下STL中迭代器的作用，有指针为何还要迭代器？" class="headerlink" title="37、说一下STL中迭代器的作用，有指针为何还要迭代器？"></a>37、<strong>说一下STL中迭代器的作用，有指针为何还要迭代器？</strong></h4><ol><li><p>迭代器的作用</p><ul><li>用于指向顺序容器和关联容器中的元素</li><li>通过迭代器可以读取它指向的元素</li><li>通过非const迭代器还可以修改其指向的元素</li></ul></li><li><p>迭代器和指针的区别</p><ul><li>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，重载了指针的一些操作符，–&gt;、++、–等。迭代器封装了指针，是一个”可遍历STL（ Standard TemplateLibrary）容器内全部或部分元素”的对象，本质是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。</li></ul></li><li><p>迭代器产生的原因</p><ul><li>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</li></ul></li></ol><h4 id="38、说说-STL-迭代器是怎么删除元素的"><a href="#38、说说-STL-迭代器是怎么删除元素的" class="headerlink" title="38、说说 STL 迭代器是怎么删除元素的"></a>38、<strong>说说 STL 迭代器是怎么删除元素的</strong></h4><ol><li><p>对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器；</p></li><li><p>对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可；</p></li><li><p>对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。</p></li></ol><h4 id="39、说说-push-back-和-emplace-back-的区别"><a href="#39、说说-push-back-和-emplace-back-的区别" class="headerlink" title="39、说说 push_back 和 emplace_back 的区别"></a>39、<strong>说说 push_back 和 emplace_back 的区别</strong></h4><ul><li>如果要将一个临时变量push到容器的末尾，push_back()需要先构造临时对象，再将这个对象拷贝到容器的末尾，而emplace_back()则直接在容器的末尾构造对象，这样就省去了拷贝的过程。</li></ul><h4 id="40、说说-STL-容器动态链接可能产生的问题？"><a href="#40、说说-STL-容器动态链接可能产生的问题？" class="headerlink" title="40、说说 STL 容器动态链接可能产生的问题？"></a>40、<strong>说说 STL 容器动态链接可能产生的问题？</strong></h4><ol><li><p>可能产生的问题</p><ul><li>容器是一种动态分配内存空间的一个变量集合类型变量。在一般的程序函数里，局部容器，参数传递容器，参数传递容器的引用，参数传递容器指针都是可以正常运行的，而在动态链接库函数内部使用容器也是没有问题的，但是给动态库函数传递容器的对象本身，则会出现内存堆栈破坏的问题。</li></ul></li><li><p>产生问题的原因</p><ul><li>容器和动态链接库相互支持不够好，动态链接库函数中使用容器时，参数中只能传递容器的引用，并且要保证容器的大小不能超出初始大小，否则导致容器自动重新分配，就会出现内存堆栈破坏问题。</li></ul></li></ol><h4 id="41、说说-STL-中-resize-和-reserve-的区别"><a href="#41、说说-STL-中-resize-和-reserve-的区别" class="headerlink" title="41、说说 STL 中 resize 和 reserve 的区别"></a>41、<strong>说说 STL 中 resize 和 reserve 的区别</strong></h4><ol><li><p>首先必须弄清楚两个概念：</p><ul><li>capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。还不能通过下标等访问，因为此时容器中还没有创建任何对象。</li><li>size：指的是此时容器中实际的元素个数。可以通过下标访问0-(size-1)范围内的对象。</li></ul></li><li><p>resize和reserve区别主要有以下几点：</p><ul><li>resize既分配了空间，也创建了对象；reserve表示容器预留空间，但并不是真正的创建对象，需要通过insert（）或push_back（）等创建对象。</li><li>resize既修改capacity大小，也修改size大小；reserve只修改capacity大小，不修改size大小。</li><li>两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve只带一个参数，表示容器预留的大小。</li></ul></li></ol><p><strong>问题延伸：</strong></p><ul><li>resize 和 reserve 既有差别，也有共同点。两个接口的共同点是它们都保证了vector的空间大小(capacity)最少达到它的参数所指定的大小。下面就他们的细节进行分析。</li><li>为实现resize的语义，resize接口做了两个保证：<ul><li>保证区间[0, new_size)范围内数据有效，如果下标index在此区间内，vector[indext]是合法的；</li><li>保证区间[0, new_size)范围以外数据无效，如果下标index在区间外，vector[indext]是非法的。</li></ul></li><li>reserve只是保证vector的空间大小(capacity)最少达到它的参数所指定的大小n。在区间[0, n)范围内，如果下标是index，vector[index]这种访问有可能是合法的，也有可能是非法的，视具体情况而定。</li></ul><h4 id="42、简单说一下traits技法"><a href="#42、简单说一下traits技法" class="headerlink" title="42、简单说一下traits技法"></a>42、<strong>简单说一下traits技法</strong></h4><p>traits技法利用“内嵌型别“的编程技巧与编译器的template参数推导功能，增强C++未能提供的关于型别认证方面的能力。常用的有iterator_traits和type_traits。</p><p><strong>iterator_traits</strong>：被称为特性萃取机，能够方便的让外界获取以下5种型别：</p><ul><li>value_type：迭代器所指对象的型别</li><li>difference_type：两个迭代器之间的距离</li><li>pointer：迭代器所指向的型别</li><li>reference：迭代器所引用的型别</li><li>iterator_category：一共有5种分别为：<ol><li>input_iterator：istream独有的迭代器。</li><li>output_iterator：ostream独有的迭代器。</li><li>forward_iterator：继承自input_iterator，单向走的迭代器，只能走一个，不能跳。如forward_list、单向list的hashtable</li><li>bidirectional_iterator：继承自forward_iterator，双向走的迭代器，只能走一个，不能跳。如list、rb-tree、双向list的hashtable</li><li>random_access_iterator：继承自bidirectional_iterator，可以跳的迭代器。如array、vector、deque。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试宝典 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础语法</title>
      <link href="/2022/09/03/c-ji-chu-yu-fa/"/>
      <url>/2022/09/03/c-ji-chu-yu-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="一、C-语言基础"><a href="#一、C-语言基础" class="headerlink" title="一、C++语言基础"></a>一、C++语言基础</h3><h4 id="1、main函数的返回值有什么值得考究之处吗？"><a href="#1、main函数的返回值有什么值得考究之处吗？" class="headerlink" title="1、main函数的返回值有什么值得考究之处吗？"></a>1、main函数的返回值有什么值得考究之处吗？</h4><ul><li>程序运行过程入口点main函数，main()函数返回值类型必须是int，这样返回值才能传递给程序激活者（如操作系统）表示程序正常退出。</li><li><code>main(int argc, char **argv)</code> 参数的传递。参数的处理，一般会调用getopt()函数处理，但实践中，这仅仅是一部分，不会经常用到的技能点。</li></ul><h4 id="2、初始化和赋值的区别"><a href="#2、初始化和赋值的区别" class="headerlink" title="2、初始化和赋值的区别"></a>2、初始化和赋值的区别</h4><ul><li><p>对于简单类型来说，初始化和赋值没什么区别</p></li><li><p>对于类和复杂数据类型来说，会调用拷贝构造函数</p></li></ul><h4 id="3、变量声明和定义区别？"><a href="#3、变量声明和定义区别？" class="headerlink" title="3、变量声明和定义区别？"></a>3、变量声明和定义区别？</h4><ul><li>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间，定义要在定义的地方为其分配存储空间。</li><li>相同变量可以在多处声明（外部变量extern），但只能在一处定义。</li></ul><h4 id="4、定义和声明的区别"><a href="#4、定义和声明的区别" class="headerlink" title="4、定义和声明的区别"></a>4、<strong>定义和声明的区别</strong></h4><ul><li>如果是指变量的声明和定义： 从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。</li><li>如果是指函数的声明和定义： 声明：一般在头文件里，对编译器说：这里我有一个函数叫function() 让编译器知道这个函数的存在。 定义：一般在源文件里，具体就是函数的实现过程写明函数体。</li></ul><h4 id="5、strlen和sizeof区别？"><a href="#5、strlen和sizeof区别？" class="headerlink" title="5、strlen和sizeof区别？"></a>5、strlen和sizeof区别？</h4><ul><li>sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</li><li>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\0’的字符串。</li><li>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。</li></ul><h4 id="6、volatile、mutable和explicit关键字的用法"><a href="#6、volatile、mutable和explicit关键字的用法" class="headerlink" title="6、volatile、mutable和explicit关键字的用法"></a>6、volatile、mutable和explicit关键字的用法</h4><p><strong>（1）volatile</strong></p><ul><li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</li><li>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。<strong>多线程中被几个任务共享的变量需要定义为volatile类型。</strong>该关键字的作用是<u>防止优化编译器把变量从内存装入CPU寄存器中。</u></li><li>可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。</li><li>C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。</li><li>volatile 指针和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念</li></ul><p><strong>（2）mutable</strong></p><ul><li>mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置。</li></ul><p><strong>（3）Explicit</strong></p><ul><li><p>explicit关键字用来修饰类的构造函数，<u>被修饰的构造函数的类，不能发生相应的隐式类型转换</u>，只能以显示的方式进行类型转换，注意以下几点：</p><ul><li>explicit 关键字只能用于类内部的构造函数声明上</li><li>explicit 关键字<strong>作用于单个参数</strong>的构造函数</li><li>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</li></ul></li></ul><h4 id="7、形参与实参的区别？"><a href="#7、形参与实参的区别？" class="headerlink" title="7、形参与实参的区别？"></a>7、形参与实参的区别？</h4><ol><li>形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。</li><li>实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。</li><li>实参和形参在数量上，类型上，顺序上应严格一致，否则会发生“类型不匹配”的错误。</li><li>函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。</li><li>当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。</li></ol><h4 id="8、值传递、指针传递、引用传递的区别和效率"><a href="#8、值传递、指针传递、引用传递的区别和效率" class="headerlink" title="8、值传递、指针传递、引用传递的区别和效率"></a>8、值传递、指针传递、引用传递的区别和效率</h4><ul><li>值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象或是大的结构体对象，将耗费一定的时间和空间。（传值）</li><li>指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）</li><li>引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）</li><li>效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。</li></ul><h4 id="9、对象复用的了解，零拷贝的了解"><a href="#9、对象复用的了解，零拷贝的了解" class="headerlink" title="9、对象复用的了解，零拷贝的了解"></a>9、<strong>对象复用的了解，零拷贝的了解</strong></h4><p><strong>对象复用：</strong></p><ul><li><p>对象复用其本质是一种设计模式：Flyweight享元模式</p></li><li><p>通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建对象的开销，节约系统资源。</p></li></ul><p><strong>零拷贝：</strong></p><ul><li>零拷贝就是一种避免CPU将数据从一块存储拷贝到另外一块存储的技术。</li><li>零拷贝技术可以减少数据拷贝和共享总线操作的次数。</li><li>在C++中，vector的一个成员函数emplace_back()很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入到容器尾部，区别在于push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造，效率更高</li></ul><h4 id="10、C-四种强制转换"><a href="#10、C-四种强制转换" class="headerlink" title="10、C++四种强制转换"></a>10、C++四种强制转换</h4><p><strong>reinterpret_cast：</strong><code>reinterpret_cast&lt;type-id&gt;(expression)</code></p><ul><li>type-id必须是一个指针、引用、算术类型、函数指针或成员指针。它可以用于类型之间进行强制转换。</li></ul><p><strong>const_cast：</strong><code>const_cast&lt;type_id&gt;(expression)</code></p><ul><li>该运算符用来修改类型的const或volatile属性。除了const或volatile修饰之外，type_id和expression的类型是一样的。用法如下：<ul><li>常量指针被转化为非常量的指针，并且仍指向原来的对象</li><li>常量引用被转换成非常量的引用，并且仍然指向原来的对象</li><li>const_cast一般用于修改底指针，如const char* p形式</li></ul></li></ul><p><strong>static_cast：</strong><code>static_cast&lt;type_id&gt;(expression)</code></p><ul><li>该运算符把expression转换为type_id类型，但没有运行时类型检查来保证转换的安全性。用法：</li><li>用于类层次结构中基类和派生类之间指针或引用的转换<ul><li>进行上行转换（派生类转换为基类）是安全的</li><li>进行下行转换，由于没有动态类型的检查，所以是不安全的</li></ul></li><li>用于基本数据类型之间的转换，如int转char，这种转换类型的安全性需要开发人员来保证。</li><li>把空指针转换为目标类型的空指针</li><li>把任何类型的表达式转换为void类型</li></ul><p><strong>dynamic_cast：</strong><code>dynamic_cast(expression)</code></p><ul><li>有类型检查，基类向派生类转换比较安全，但派生类转基类不太安全</li><li>该运算符把expression转换成type_id类型的对象。type_id必须是类的指针，类的引用或void*</li><li>如果type_id是类指针类型，那么expression也必须是一个指针，如果type_id是一个引用，那么expression也必须是一个引用</li><li>dynamic_cast运算符可以在执行期间决定真正的类型，也就是说expression必须是多态类型，如果下行转换是安全的，这个运算符会传回适当转型过的指针。如果下行转换不安全，这个运算符会传回空指针</li><li>dynamic_cast主要用于类层次间的上下行转换，还可以用于类之间的交叉转换<ul><li>上行和static_cast一样–安全的</li><li>下行有类型检查的功能，比static_cast安全</li></ul></li></ul><h4 id="11、C-函数调用的压栈的过程"><a href="#11、C-函数调用的压栈的过程" class="headerlink" title="11、C++函数调用的压栈的过程"></a>11、<strong>C++函数调用的压栈的过程</strong></h4><p>函数调用过程：</p><ol><li>栈空间分配存储空间</li><li>从实参的存储空间复制到形参的栈空间</li><li>进行运算<ul><li>形参在函数未调用前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间</li><li>数组作为参数的函数调用方式是地址传递，形参和实参都是指向相同的内存空间，调用完毕之后形参指针被销毁，但是所指向的内存依旧存在，不能也不会被销毁</li><li>当函数有多个返回值时，不能用普通的return方式实现，需要通过传回地址的形式进行，即地址&#x2F;指针传递</li></ul></li></ol><h4 id="12、写C-代码时有一类错误coredump，很常见，你遇到过吗？怎么调式这个错误？"><a href="#12、写C-代码时有一类错误coredump，很常见，你遇到过吗？怎么调式这个错误？" class="headerlink" title="12、写C++代码时有一类错误coredump，很常见，你遇到过吗？怎么调式这个错误？"></a>12、写C++代码时有一类错误coredump，很常见，你遇到过吗？怎么调式这个错误？</h4><ul><li>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成一个叫做core的文件，这个文件会记录运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的对栈调试信息。</li></ul><h4 id="13、C-中将临时变量作为返回值时的处理过程"><a href="#13、C-中将临时变量作为返回值时的处理过程" class="headerlink" title="13、C++中将临时变量作为返回值时的处理过程"></a>13、<strong>C++中将临时变量作为返回值时的处理过程</strong></h4><ul><li>首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，<u>临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了</u></li><li>C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit</li><li><strong>函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系。如果我们需要返回值，一般使用赋值语句就可以了。</strong></li></ul><h4 id="14、如何获得结构成员相对于结构开头的字节偏移量"><a href="#14、如何获得结构成员相对于结构开头的字节偏移量" class="headerlink" title="14、如何获得结构成员相对于结构开头的字节偏移量"></a>14、<strong>如何获得结构成员相对于结构开头的字节偏移量</strong></h4><ul><li>使用&lt;stddef.h&gt;头文件中的，offsetof宏。</li></ul><h4 id="15、静态类型和动态类型，静态绑定和动态绑定的介绍"><a href="#15、静态类型和动态类型，静态绑定和动态绑定的介绍" class="headerlink" title="15、静态类型和动态类型，静态绑定和动态绑定的介绍"></a>15、<strong>静态类型和动态类型，静态绑定和动态绑定的介绍</strong></h4><ul><li>静态类型：对象在声明时采用的类型，在编译期既已确定；</li><li>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</li><li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</li><li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</li></ul><p>静态绑定和动态绑定的区别：</p><ul><li>静态绑定发生在编译期，动态绑定发生在运行期；</li><li>对象的动态类型可以更改，但是静态类型无法更改；</li><li>要想实现动态，必须使用动态绑定；</li><li><strong>在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；</strong></li></ul><h4 id="16、你知道静态绑定和动态绑定吗"><a href="#16、你知道静态绑定和动态绑定吗" class="headerlink" title="16、你知道静态绑定和动态绑定吗?"></a>16、<strong>你知道静态绑定和动态绑定吗?</strong></h4><ul><li>对象的静态类型：对象在声明时采用的类型。是在编译期确定的。</li><li>对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。</li><li>静态绑定：绑定的是对象的静态类型，某特性（比如函数依赖于对象的静态类型，发生在编译期。)</li><li>动态绑定：绑定的是对象的动态类型，某特性（比如函数依赖于对象的动态类型，发生在运行期。)</li></ul><h4 id="17、引用是否能实现动态绑定，为什么可以实现？"><a href="#17、引用是否能实现动态绑定，为什么可以实现？" class="headerlink" title="17、引用是否能实现动态绑定，为什么可以实现？"></a>17、<strong>引用是否能实现动态绑定，为什么可以实现？</strong></h4><p>可以。</p><ul><li>引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。注意只能调用虚函数。需要说明的是<u>虚函数才具有动态绑定</u></li></ul><h4 id="18、类如何实现只能静态分配和只能动态分配"><a href="#18、类如何实现只能静态分配和只能动态分配" class="headerlink" title="18、类如何实现只能静态分配和只能动态分配"></a>18、<strong>类如何实现只能静态分配和只能动态分配</strong></h4><ul><li>前者是把new、delete运算符重载为private属性。后者是把构造、析构函数设为protected属性，再用子类来动态创建</li></ul><p><strong>建立类的对象有两种方式：</strong></p><ol><li>静态建立，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；</li><li>动态建立，A *p &#x3D; new A();动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上，可以将new运算符设为私有。</li></ol><h4 id="19、全局变量和局部变量有什么区别？"><a href="#19、全局变量和局部变量有什么区别？" class="headerlink" title="19、全局变量和局部变量有什么区别？"></a>19、<strong>全局变量和局部变量有什么区别？</strong></h4><ul><li><strong>生命周期不同：</strong>全局变量随主程序创建而创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</li><li><strong>使用方式不同：</strong>通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。</li><li>操作系统和编译器通过内存分配的位置可以区分两者，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面。</li></ul><h4 id="20、怎样判断两个浮点数是否相等？"><a href="#20、怎样判断两个浮点数是否相等？" class="headerlink" title="20、怎样判断两个浮点数是否相等？"></a>20、<strong>怎样判断两个浮点数是否相等？</strong></h4><ul><li>对两个浮点数判断大小和是否相等不能直接用&#x3D;&#x3D;来判断，会出错！明明相等的两个数比较反而是不相等！<strong>对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！</strong>浮点数与0的比较也应该注意。与浮点数的表示方式有关。</li></ul><h4 id="21、nullptr调用成员函数可以吗？为什么？"><a href="#21、nullptr调用成员函数可以吗？为什么？" class="headerlink" title="21、nullptr调用成员函数可以吗？为什么？"></a>21、nullptr调用成员函数可以吗？为什么？</h4><ul><li>能，因为在<strong>编译时对象</strong>就绑定了<strong>函数地址</strong>，和指针空不空没关系。</li></ul><h4 id="22、你知道重载运算符吗？"><a href="#22、你知道重载运算符吗？" class="headerlink" title="22、你知道重载运算符吗？"></a>22、<strong>你知道重载运算符吗？</strong></h4><ol><li>我们只能重载已有的运算符，而无权发明新的运算符；对于一个重载的运算符，其优先级和结合律与内置类型一致才可以；不能改变运算符操作数个数；</li><li>两种重载方式：<u>成员运算符和非成员运算符</u>，成员运算符比非成员运算符少一个参数；下标运算符、箭头运算符必须是成员运算符；</li><li>引入运算符重载，是为了实现类的多态性；</li><li><strong>当重载的运算符是成员函数时，this绑定到左侧运算符对象。成员运算符函数的参数数量比运算符对象的数量少一个；至少含有一个类类型的参数；</strong></li><li>从参数的个数推断到底定义的是哪种运算符，当运算符既是一元运算符又是二元运算符（+，-，*，&amp;）；</li><li>下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本；</li><li>箭头运算符必须是类的成员，解引用通常也是类的成员；重载的箭头运算符必须返回类的指针；</li></ol><h4 id="23、当程序中有函数重载时，函数的匹配原则和顺序是什么？"><a href="#23、当程序中有函数重载时，函数的匹配原则和顺序是什么？" class="headerlink" title="23、当程序中有函数重载时，函数的匹配原则和顺序是什么？"></a>23、<strong>当程序中有函数重载时，函数的匹配原则和顺序是什么？</strong></h4><ol><li>名字查找</li><li>确定候选函数</li><li>寻找最佳匹配</li></ol><h4 id="24、函数调用过程栈的变化，返回值和参数变量哪个先入栈？"><a href="#24、函数调用过程栈的变化，返回值和参数变量哪个先入栈？" class="headerlink" title="24、函数调用过程栈的变化，返回值和参数变量哪个先入栈？"></a>24、<strong>函数调用过程栈的变化，返回值和参数变量哪个先入栈？</strong></h4><ol><li>按照形参顺序相反的顺序压入栈中,<strong>即:从右向左依次把被调函数所需要的参数压入栈</strong>;</li><li>调用者函数使用call指令调用被调函数,并把call指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作隐含在call指令中);</li><li>在被调函数中,被调函数会先保存调用者函数的栈底地址(push ebp),然后再保存调用者函数的栈顶地址,即:当前被调函数的栈底地址(mov ebp,esp)，在被调函数中,从ebp的位置处开始存放被调函数中的局部变量和临时变量,并且这些变量的地址按照定义时的顺序依次减小,即:这些变量的地址是按照栈的延伸方向排列的,先定义的变量先入栈,后定义的变量后入栈;</li></ol><h4 id="25、C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"><a href="#25、C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？" class="headerlink" title="25、C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"></a>25、<strong>C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</strong></h4><ol><li><p><strong>指针参数传递本质上是值传递，它所传递的是一个地址值。</strong></p><ul><li>值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。</li></ul></li><li><p><strong>引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。</strong></p><ul><li>被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。</li></ul></li><li><p><strong>引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。</strong>而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。</p></li><li><p><strong>从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。</strong>指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。</p></li></ol><h4 id="28、你知道printf函数的实现原理是什么吗？"><a href="#28、你知道printf函数的实现原理是什么吗？" class="headerlink" title="28、你知道printf函数的实现原理是什么吗？"></a>28、你知道printf函数的实现原理是什么吗？</h4><ul><li><p>在C&#x2F;C++中，对函数参数的扫描是从后向前的。</p></li><li><p>C&#x2F;C++的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。</p></li><li><p><strong>printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了</strong></p></li></ul><h4 id="30、方法调用的原理（栈，汇编）"><a href="#30、方法调用的原理（栈，汇编）" class="headerlink" title="30、方法调用的原理（栈，汇编）"></a>30、方法调用的原理（栈，汇编）</h4><ul><li>机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。而为单个过程分配的那部分栈称为帧栈；帧栈可以认为是程序栈的一段，它有两个端点，一个标识起始地址，一个标识着结束地址，两个指针结束地址指针esp，开始地址指针ebp;</li><li>由一系列栈帧构成，这些栈帧对应一个过程，而且每一个栈指针+4的位置存储函数返回地址；每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。</li></ul><p><strong>过程实现</strong></p><ol><li>备份原来的帧指针，调整当前的栈帧指针到栈指针位置；</li><li>建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存；</li><li>使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。</li><li>恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了</li><li>释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理。</li><li>恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置。</li><li>弹出返回地址，跳出当前过程，继续执行调用者的代码。</li></ol><p><strong>过程调用和返回指令</strong></p><ol><li>call指令</li><li>leave指令</li><li>ret指令</li></ol><h4 id="31、说一下你理解的-ifdef-endif代表着什么？"><a href="#31、说一下你理解的-ifdef-endif代表着什么？" class="headerlink" title="31、说一下你理解的 ifdef endif代表着什么？"></a>31、说一下你理解的 ifdef endif代表着什么？</h4><ol><li>一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。</li><li>在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。<strong>在头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件重定义。</strong></li></ol><h4 id="32、隐式转换，如何消除隐式转换？"><a href="#32、隐式转换，如何消除隐式转换？" class="headerlink" title="32、隐式转换，如何消除隐式转换？"></a>32、<strong>隐式转换，如何消除隐式转换？</strong></h4><ol><li>C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。<strong>所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。</strong>很多时候用户可能都不知道进行了哪些转换</li><li><strong>C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。通过隐式转换，你可以直接将一个子类的对象使用父类的类型进行返回。</strong>在比如，数值和布尔类型的转换，整数和浮点数的转换等。某些方面来说，隐式转换给C++程序开发者带来了不小的便捷。C++是一门强类型语言，类型的检查是非常严格的。</li><li><strong>基本数据类型</strong> 基本数据类型的转换以取值范围的作为转换基础（保证精度不丢失）。隐式转换发生在从<strong>小-&gt;大</strong>的转换中。比如从char转换为int。从int-&gt;long。自定义对象 子类对象可以隐式的转换为父类对象。</li><li><strong>C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。</strong></li><li>如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换，<strong>关键字explicit只对一个实参的构造函数有效</strong>，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。</li></ol><h4 id="33、C-如何处理多个异常的？"><a href="#33、C-如何处理多个异常的？" class="headerlink" title="33、C++如何处理多个异常的？"></a>33、<strong>C++如何处理多个异常的？</strong></h4><ol><li><p>C++中的异常情况： </p><ul><li><strong>语法错误（编译错误）：比如变量未定义、括号不匹配、关键字拼写错误等等编译器在编译时能发现的错误</strong>，这类错误可以及时被编译器发现，而且可以及时知道出错的位置及原因，方便改正。 </li><li><strong>运行时错误：比如数组下标越界、系统内存不足等等。这类错误不易被程序员发现</strong>，它能通过编译且能进入运行，但运行时会出错，导致程序崩溃。为了有效处理程序运行时错误，C++中引入异常处理机制来解决此问题。</li></ul></li><li><p>C++异常处理机制： 异常处理基本思想：执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理， 而是抛出该异常，让函数的调用者直接或间接处理这个问题。 C++异常处理机制由3个模块组成：try(检查)、throw(抛出)、catch(捕获) 抛出异常的语句格式为：throw 表达式；如果try块中程序段发现了异常则抛出异常。</p></li></ol><h4 id="34、如何在不使用额外空间的情况下，交换两个数？你有几种方法"><a href="#34、如何在不使用额外空间的情况下，交换两个数？你有几种方法" class="headerlink" title="34、如何在不使用额外空间的情况下，交换两个数？你有几种方法"></a>34、<strong>如何在不使用额外空间的情况下，交换两个数？你有几种方法</strong></h4><ol><li>算术</li></ol><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">x = x + y;y = x - y;x = x - y; </code></pre><ol start="2"><li>异或</li></ol><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">x = x^y;// 只能对int,char..y = x^y;x = x^y;x ^= y ^= x;</code></pre><h4 id="35、你知道strcpy和memcpy的区别是什么吗？"><a href="#35、你知道strcpy和memcpy的区别是什么吗？" class="headerlink" title="35、你知道strcpy和memcpy的区别是什么吗？"></a>35、<strong>你知道strcpy和memcpy的区别是什么吗？</strong></h4><ol><li><strong>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容</strong>，例如字符数组、整型、结构体、类等。 </li><li><strong>复制的方法不同。</strong>strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。 </li><li><strong>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</strong></li></ol><h4 id="36、程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？"><a href="#36、程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？" class="headerlink" title="36、程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？"></a>36、程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？</h4><ul><li>参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]，所有的参数在指针</li><li><code>char *</code> 指向的内存中，数组的中元素的个数为 argc 个，第一个参数为程序的名称。</li></ul><h4 id="37、volatile关键字的作用？"><a href="#37、volatile关键字的作用？" class="headerlink" title="37、volatile关键字的作用？"></a>37、volatile关键字的作用？</h4><ul><li><strong>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改</strong>，比如：操作系统、硬件或者其它线程等。<strong>遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</strong></li><li>声明时语法：<code>int volatile vInt;</code> 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</li></ul><p><strong>volatile用在如下的几个地方：</strong></p><ol><li>中断服务程序中修改的供其它程序检测的变量需要加volatile；</li><li>多任务环境下各任务间共享的标志应该加volatile；</li><li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义；</li></ol><h4 id="38、如果有一个空类，它会默认添加哪些函数？"><a href="#38、如果有一个空类，它会默认添加哪些函数？" class="headerlink" title="38、如果有一个空类，它会默认添加哪些函数？"></a>38、<strong>如果有一个空类，它会默认添加哪些函数？</strong></h4><ol><li><p>Empty(); &#x2F;&#x2F; 缺省构造函数&#x2F;&#x2F;</p></li><li><p>Empty( const Empty&amp; ); &#x2F;&#x2F; 拷贝构造函数&#x2F;&#x2F;</p></li><li><p>~Empty(); &#x2F;&#x2F; 析构函数&#x2F;&#x2F;</p></li><li><p>Empty&amp; operator&#x3D;( const Empty&amp; ); &#x2F;&#x2F; 赋值运算符&#x2F;&#x2F;</p></li></ol><h4 id="39、C-中标准库是什么？"><a href="#39、C-中标准库是什么？" class="headerlink" title="39、C++中标准库是什么？"></a>39、<strong>C++中标准库是什么？</strong></h4><p>C++ 标准库可以分为两部分：</p><ul><li><p>标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。</p></li><li><p>面向对象类库： 这个库是类及其相关函数的集合。</p></li><li><p>输入&#x2F;输出 I&#x2F;O、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数</p></li><li><p>标准的 C++ I&#x2F;O 类、String 类、数值类、STL 容器类、STL 算法、STL 函数对象、STL 迭代器、STL 分配器、本地化库、异常处理类、杂项支持库</p></li></ul><h4 id="40、你知道-const-char-与string之间的关系是什么吗？"><a href="#40、你知道-const-char-与string之间的关系是什么吗？" class="headerlink" title="40、你知道*const* char* 与string之间的关系是什么吗？"></a>40、<strong>你知道</strong><em><strong>*const*</strong></em> <strong>char* 与string之间的关系是什么吗？</strong></h4><ul><li><strong>string 是c++标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用const char*给string类初始化</strong></li></ul><h4 id="41、你什么情况用指针当参数，什么时候用引用，为什么？"><a href="#41、你什么情况用指针当参数，什么时候用引用，为什么？" class="headerlink" title="41、你什么情况用指针当参数，什么时候用引用，为什么？"></a>41、<strong>你什么情况用指针当参数，什么时候用引用，为什么？</strong></h4><p>使用引用参数的主要原因有：</p><ul><li><p>程序员能修改调用函数中的数据对象</p></li><li><p>通过传递引用而不是整块数据–对象，可以提高程序的运行速度</p></li></ul><p>一般的原则： 对于使用引用的值而不做修改的函数：</p><ul><li><p>如果数据对象很小，如内置数据类型或者小型结构，则按照值传递；</p></li><li><p>如果数据对象是数组，则使用指针（唯一的选择），并且指针声明为指向const的指针；</p></li><li><p>如果数据对象是较大的结构，则使用const指针或者引用，已提高程序的效率。这样可以节省结构所需的时间和空间；</p></li><li><p><strong>如果数据对象是类对象，则使用const引用（传递类对象参数的标准方式是按照引用传递）；</strong></p></li></ul><p>对于修改函数中数据的函数：</p><ul><li><p>如果数据是内置数据类型，则使用指针</p></li><li><p>如果数据对象是结构，则使用引用或者指针</p></li><li><p>如果数据是类对象，则使用引用</p></li></ul><h4 id="42、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？"><a href="#42、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？" class="headerlink" title="42、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？"></a>42、<strong>在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？</strong></h4><p>对比值传递，引用传参的好处：</p><ol><li><strong>在函数内部可以对此参数进行修改</strong></li><li><strong>提高函数调用和运行的效率</strong>（因为没有了传值和生成副本的时间和空间消耗）</li></ol><p>如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参&#x3D;实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。</p><p>用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。<strong>但是有以下的限制：</strong></p><ol><li><strong>不能返回局部变量的引用。</strong>因为函数返回以后局部变量就会被销毁</li><li><strong>不能返回函数内部new分配的内存的引用。</strong>虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak</li><li><strong>可以返回类成员的引用，但是最好是const。</strong>因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。</li></ol><h4 id="43、怎么快速定位错误出现的地方"><a href="#43、怎么快速定位错误出现的地方" class="headerlink" title="43、怎么快速定位错误出现的地方?"></a>43、怎么快速定位错误出现的地方?</h4><ol><li>如果是简单的错误，可以直接双击错误列表里的错误项或者生成输出的错误信息中带行号的地方就可以让编辑窗口定位到错误的位置上。</li><li>对于复杂的模板错误，最好使用生成输出窗口。</li><li>多数情况下触发错误的位置是最靠后的引用位置。如果这样确定不了错误，就需要先把自己写的代码里的引用位置找出来，然后逐个分析了。</li></ol><h4 id="44、如何设计一个计算仅单个子类的对象个数？"><a href="#44、如何设计一个计算仅单个子类的对象个数？" class="headerlink" title="44、如何设计一个计算仅单个子类的对象个数？"></a>44、<strong>如何设计一个计算仅单个子类的对象个数？</strong></h4><ol><li>为类设计一个static静态变量count作为计数器；</li><li>类定义结束后初始化count;</li><li>在构造函数中对count进行+1;</li><li>设计拷贝构造函数，在进行拷贝构造函数中进行count +1，操作；</li><li>设计复制构造函数，在进行复制函数中对count+1操作；</li><li>在析构函数中对count进行-1；</li></ol><h4 id="45、成员初始化列表会在什么时候用到？它的调用过程是什么？"><a href="#45、成员初始化列表会在什么时候用到？它的调用过程是什么？" class="headerlink" title="45、成员初始化列表会在什么时候用到？它的调用过程是什么？"></a>45、<strong>成员初始化列表会在什么时候用到？它的调用过程是什么？</strong></h4><ol><li>当初始化一个引用成员变量时；</li><li>初始化一个const成员变量时；</li><li>当调用一个基类的构造函数，而构造函数拥有一组参数时；</li><li>当调用一个成员类的构造函数，而他拥有一组参数；</li><li>编译器会一一操作初始化列表，以适当顺序在构造函数之内安插初始化操作，并且在任何显示用户代码前。list中的项目顺序是由类中的成员声明顺序决定的，不是初始化列表中的排列顺序决定的。</li></ol><h4 id="46、你知道回调函数吗？它的作用？"><a href="#46、你知道回调函数吗？它的作用？" class="headerlink" title="46、你知道回调函数吗？它的作用？"></a>46、你知道回调函数吗？它的作用？</h4><ol><li><strong>当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数</strong>；</li><li><strong>回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。</strong>为此，你需要做三件事：<strong>1，声明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；</strong></li><li><strong>回调函数就是一个通过函数指针调用的函数。</strong>如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；</li><li>因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。</li></ol><h4 id="47、成员函数里memset-this-0-sizeof-this-会发生什么"><a href="#47、成员函数里memset-this-0-sizeof-this-会发生什么" class="headerlink" title="47、成员函数里memset(this,0,sizeof(*this))会发生什么"></a>47、<strong>成员函数里memset(this,0,sizeof(*this))会发生什么</strong></h4><ul><li>有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就memset(this, 0, sizeof *this);将整个对象的内存全部置为0。对于这种情形可以很好的工作，但是下面几种情形是不可以这么使用的；<ul><li>类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常；</li><li>类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存。</li></ul></li></ul><h4 id="48、说一说strcpy、sprintf与memcpy这三个函数的不同之处"><a href="#48、说一说strcpy、sprintf与memcpy这三个函数的不同之处" class="headerlink" title="48、说一说strcpy、sprintf与memcpy这三个函数的不同之处"></a>48、<strong>说一说strcpy、sprintf与memcpy这三个函数的不同之处</strong></h4><p><strong>操作对象不同</strong></p><ol><li>strcpy的两个操作对象均为字符串</li><li>sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串</li><li>memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</li></ol><p><strong>执行效率不同</strong></p><ol><li>memcpy最高，strcpy次之，sprintf的效率最低。</li></ol><p><strong>实现功能不同</strong></p><ol><li>strcpy主要实现字符串变量间的拷贝</li><li>sprintf主要实现其他数据类型格式到字符串的转化</li><li>memcpy主要是内存块间的拷贝。</li></ol><h4 id="49、将引用作为函数参数有哪些好处？"><a href="#49、将引用作为函数参数有哪些好处？" class="headerlink" title="49、将引用作为函数参数有哪些好处？"></a>49、<strong>将引用作为函数参数有哪些好处？</strong></h4><ol><li><p>传递引用给函数与传递指针的效果是一样的。</p><ul><li>这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。</li></ul></li><li><p><strong>使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；</strong></p><ul><li>而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；</li><li>如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</li></ul></li><li><p>使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</p></li></ol><h4 id="50、你知道Debug和Release的区别是什么吗？"><a href="#50、你知道Debug和Release的区别是什么吗？" class="headerlink" title="50、你知道Debug和Release的区别是什么吗？"></a>50、<strong>你知道Debug和Release的区别是什么吗？</strong></h4><ol><li>调试版本，包含调试信息，所以容量比Release大很多，并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。Debug模式下生成两个文件，除了.exe或.dll文件外，还有一个.pdb文件，该文件记录了代码中断点等调试信息；</li><li>发布版本，不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。（调试信息可在单独的PDB文件中生成）。Release模式下生成一个文件.exe或.dll文件。</li><li>实际上，Debug 和 Release 并没有本质的界限，他们只是一组编译选项的集合，编译器只是按照预定的选项行动。事实上，我们甚至可以修改这些选项，从而得到优化过的调试版本或是带跟踪语句的发布版本。</li></ol><h4 id="51、strcpy函数和strncpy函数的区别？哪个函数更安全？"><a href="#51、strcpy函数和strncpy函数的区别？哪个函数更安全？" class="headerlink" title="51、strcpy函数和strncpy函数的区别？哪个函数更安全？"></a>51、<strong>strcpy</strong>函数和strncpy函数的区别？哪个函数更安全？</h4><p><code>char* strcpy(char* strDest, const char* strSrc)</code></p><p><code>char *strncpy(char *dest, const char *src, size_t n)</code></p><ul><li><p>strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。</p></li><li><p>strncpy函数：用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。 </p><ul><li>如果目标长&gt;指定长&gt;源长，则将源长全部拷贝到目标长，自动加上’\0’</li><li>如果指定长&lt;源长，则将源长中按指定长度拷贝到目标字符串，不包括’\0’</li><li>如果指定长&gt;目标长，运行时错误</li></ul></li></ul><h4 id="52、模板会写吗？写一个比较大小的模板函数"><a href="#52、模板会写吗？写一个比较大小的模板函数" class="headerlink" title="52、模板会写吗？写一个比较大小的模板函数"></a>52、<strong>模板会写吗？写一个比较大小的模板函数</strong></h4><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">#include<iostream> using namespace std; template<typename type1,typename type2>//函数模板 type1 Max(type1 a,type2 b) &#123;    return a > b ? a : b; &#125; void main()  &#123;   cout<<"Max = "<<Max(5.5,'a')<<endl; &#125; </code></pre><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMDE4NDUzNg==&mid=2247484003&idx=1&sn=afeb664bf51d596a53a554b82749e511&chksm=97693254a01ebb42fa735294c62fa4771cfa5bbed3961bcb83028dd663c1aff32d81f1af0a76&scene=178&cur_album_id=2521475920096985089#rd">来源公众号：写bug那些事</a></p><p><a href="https://blog.csdn.net/CltCj?type=blog">我的CSDN</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试宝典 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> 基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
