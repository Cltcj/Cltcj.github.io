<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于跳表实现的键值型存储引擎</title>
      <link href="/2022/09/19/ji-yu-tiao-biao-shi-xian-de-jian-zhi-xing-cun-chu-yin-qing/"/>
      <url>/2022/09/19/ji-yu-tiao-biao-shi-xian-de-jian-zhi-xing-cun-chu-yin-qing/</url>
      
        <content type="html"><![CDATA[<h1 id="基于跳表实现的键值型存储引擎"><a href="#基于跳表实现的键值型存储引擎" class="headerlink" title="基于跳表实现的键值型存储引擎"></a>基于跳表实现的键值型存储引擎</h1><h2 id="1-项目说明"><a href="#1-项目说明" class="headerlink" title="1 项目说明"></a>1 项目说明</h2><p><strong>Key-Value 存储引擎</strong> 🌻</p><p>基于 <strong>跳表</strong> 实现的 KV 存储引擎，使用 C++ 实现。在随机读写情况下，该项目每秒可处理请求数（QPS）：24.39 W，每秒可处理读请求数：18.41 W。</p><p><strong>提供接口</strong> ：</p><ul><li>insert_element 插入数据</li><li>delete_element 删除数据</li><li>search_element 查询数据</li><li>display_list 打印跳跃表</li><li>dump_file 数据落盘</li><li>load_file 加载数据</li><li>size 返回数据规模</li><li>clear 清空跳表</li></ul><h2 id="2-项目代码"><a href="#2-项目代码" class="headerlink" title="2 项目代码"></a>2 项目代码</h2><p>所有实现代码位于 <code>skiplist.h</code> 头文件中，CPP 文件中 include 它就可以使用。内部关键在于定义了 <code>SkipList</code> 结构，以及 <code>Node</code> 结构。</p><h3 id="2-1-头文件"><a href="#2-1-头文件" class="headerlink" title="2.1 头文件"></a>2.1 头文件</h3><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">#include <iostream> #include <cstdlib>#include <cmath>#include <cstring>#include <mutex>#include <fstream></code></pre><h3 id="2-2-基本定义"><a href="#2-2-基本定义" class="headerlink" title="2.2 基本定义"></a>2.2 基本定义</h3><ul><li>宏定义数据落盘位置，以及加载数据位置；</li><li>定义互斥量锁，用于写操作中的临界区；</li><li>定义分隔符，用于加载数据是识别 <strong>Key</strong> 和 <strong>Value</strong> 。</li></ul><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">#define STORE_FILE "store/dumpFile"std::mutex mtx, mtx1;  std::string delimiter = ":";</code></pre><h3 id="2-3-Node"><a href="#2-3-Node" class="headerlink" title="2.3 Node"></a>2.3 Node</h3><h4 id="2-3-1-Node-定义"><a href="#2-3-1-Node-定义" class="headerlink" title="2.3.1 Node 定义"></a>2.3.1 Node 定义</h4><p><code>Node</code> 结构是 <code>SkipList</code> 实现的基础。其包括：</p><ul><li>数据成员：<code>&#123;key : value&#125;</code>，节点层数 <code>node_level</code>，前向指针数组<code>forward</code>,内部存放前向指针，指向下一个 <code>Node</code></li><li>成员函数：构造函数，析构函数，键值对操作函数</li></ul><p>具体定义如下：</p><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">// Class template to implement nodetemplate<typename K, typename V> class Node &#123;// ~ Node 节点定义public:        Node() &#123;&#125;            //  默认构造函数    Node(K k, V v, int); // 有参构造函数    ~Node();             // 析构函数    K get_key() const;   // 取 Key    V get_value() const; // 取 value    void set_value(V);   // 设定 value        // 前向指针数组，对于不同的层，可能指向不同节点    Node<K, V> **forward; // 前向指针数组,内部存放前向指针，指向下一个 Node    int node_level;      // 节点层数private:    K key;     V value;&#125;;</code></pre><h4 id="2-3-2-构造函数和析构函数"><a href="#2-3-2-构造函数和析构函数" class="headerlink" title="2.3.2 构造函数和析构函数"></a>2.3.2 构造函数和析构函数</h4><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">template<typename K, typename V> Node<K, V>::Node(const K k, const V v, int level) &#123;    this->key = k;    this->value = v;    this->node_level = level;        // forward 大小为 level + 1    this->forward = new Node<K, V>*[level + 1]; // 分配内存    memset(this->forward, 0, sizeof(Node<K, V>*)*(level + 1)); // 初始化&#125;;template<typename K, typename V> Node<K, V>::~Node() &#123;    delete []forward;  // 释放内存&#125;;</code></pre><h4 id="2-3-3-键值对操作函数"><a href="#2-3-3-键值对操作函数" class="headerlink" title="2.3.3 键值对操作函数"></a>2.3.3 键值对操作函数</h4><ul><li>这三个函数的作用主要是从<code>private</code>中取出<code>key</code>和<code>value</code>，以及通过<code>this</code>指针设置<code>value</code></li></ul><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">template<typename K, typename V> K Node<K, V>::get_key() const &#123;    return key;&#125;;template<typename K, typename V> V Node<K, V>::get_value() const &#123;    return value;&#125;;template<typename K, typename V> void Node<K, V>::set_value(V value) &#123;    this->value = value;&#125;;</code></pre><h3 id="2-4-SkipList"><a href="#2-4-SkipList" class="headerlink" title="2.4 SkipList"></a>2.4 SkipList</h3><h4 id="2-4-1-SkipList-定义"><a href="#2-4-1-SkipList-定义" class="headerlink" title="2.4.1 SkipList 定义"></a>2.4.1 SkipList 定义</h4><p><code>SkipList</code>跳表所需：</p><ul><li><p>成员变量：<code>_max_level, _skip_list_level, _element_count, header, _file_writer, file_reader</code></p></li><li><p>成员函数：构造函数，析构函数，创建节点函数，增删改查操作函数，清空跳表，数据落盘和加载数据及其相关函数，打印跳表函数，返回跳表节点数函数，获得随机层高函数 。</p></li></ul><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">template <typename K, typename V> class SkipList &#123;public:     // 构造和析构函数，创建 Node 节点函数    SkipList(int);     ~SkipList();       Node<K, V>* create_node(K, V, int);        // 增删改查操作函数    int insert_element(K, V);    // 增    int delete_element(K);     // 删    int update_element(K, V, bool);  // 改    bool search_element(K); // 查        void display_list();  // 打印跳表    void clear();   // 清空跳表    int size();  // 返回跳表节点数(不包含头节点)           // 数据落盘和数据加载    void dump_file();    void load_file();        // 获得随机层高函数    int get_random_level(); private:    // 数据加载相关函数, 用来区分 key 和 value    void get_key_value_from_string(const std::string& str, std::string* key, std::string* value);    bool is_valid_string(const std::string& str);private:        int _max_level;     // 跳表层数上限    int _skip_list_level;  // 当前跳表的最高层     int _element_count;    // 跳表中节点数    Node<K, V> *_header;   // 跳表中头节点指针    // file operator    std::ofstream _file_writer;    std::ifstream _file_reader; &#125;;</code></pre><h4 id="2-4-2-构造函数、析构函数、节点构造函数"><a href="#2-4-2-构造函数、析构函数、节点构造函数" class="headerlink" title="2.4.2 构造函数、析构函数、节点构造函数"></a>2.4.2 构造函数、析构函数、节点构造函数</h4><p>上面提到<code>Node</code>是<code>SkipList</code>所需的基本数据结构，所以这里提供</p><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">template<typename K, typename V> SkipList<K, V>::SkipList(int max_level) &#123;    this->_max_level = max_level;    this->_skip_list_level = 0;    this->_element_count = 0;    K k; V v;    this->_header = new Node<K, V>(k, v, _max_level);&#125;;template<typename K, typename V> SkipList<K, V>::~SkipList() &#123;    if (_file_writer.is_open()) &#123;        _file_writer.close();    &#125;    if (_file_reader.is_open()) &#123;        _file_reader.close();    &#125;    delete _header;&#125;template<typename K, typename V>Node<K, V>* SkipList<K, V>::create_node(const K k, const V v, int level) &#123;    Node<K, V> *n = new Node<K, V>(k, v, level);    return n;&#125;</code></pre><hr><h4 id="2-4-3-获得随机层高函数以及返回跳表大小函数"><a href="#2-4-3-获得随机层高函数以及返回跳表大小函数" class="headerlink" title="2.4.3 获得随机层高函数以及返回跳表大小函数"></a>2.4.3 获得随机层高函数以及返回跳表大小函数</h4><ul><li>这是跳表进行插入节点时，用来确定插入节点所要插入的层数</li></ul><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">template<typename K, typename V>int SkipList<K, V>::get_random_level()&#123;    int k = 1;    while (rand() % 2) &#123;        k++;    &#125;    k = (k < _max_level) ? k : _max_level; // 最大不超过上限    return k;&#125;;template<typename K, typename V> int SkipList<K, V>::size() &#123;     return _element_count;  // 会随着节点的添加, 删除, 更新改变&#125;</code></pre><p>下面就是跳表的核心逻辑部分了：</p><h4 id="2-4-4-insert-element"><a href="#2-4-4-insert-element" class="headerlink" title="2.4.4 insert_element()"></a>2.4.4 insert_element()</h4><p>我讲一下插入节点的具体操作：</p><ol><li>插入操作，实际上就相当于写入操作，所以一开始我们需要加锁;</li><li>我们使用一个<code>Node</code>指针指向跳表中的头结点指针<code>_header</code>，这里不明白的回头看<strong>2.4.2</strong>;<img src="C:/Users/ASUS/AppData/Roaming/Typora/typora-user-images/image-20220918191455371.png" alt="image-20220918191455371"></li><li>使用一个<code>Node</code>指针数组<code>update</code>，里面存放指针，指向<code>Node</code>节点，并使用<code>memset</code>函数对其进行初始化;</li><li>从跳表的最高层向下遍历，只要当前节点的下一节点非空，且 <code>key</code> 小于目标, 就会向后遍历，每遍历一层就将当前层符合要求的节点记录到<code>update</code>数组里面;</li><li>得到了这个数组之后，我们现在就知道了，诶，要往哪些节点后进行插入节点了，注意，我用的是哪些;</li><li>如果当前节点不为空，并且插入元素已经存在，就返回-1，表示插入失败;</li><li>如果当前 <code>current</code> 不存在，或者 <code>current-&gt;get_key &gt; key</code>，这就可以进行插入操作了：</li><li>随机生成层的高度，也即 <code>forward[]</code> 大小，如果新添加的节点层高大于当前跳表层高，则需要更新 <code>update</code> 数组，将原本<code>[_skip_list_level, random_level]</code>范围内的NULL改为<code>_header</code>，得到最终确定的层高后，就可以创建节点，挨层进行插入;</li><li>插入完成，进行解锁并返回;</li></ol><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">template<typename K, typename V>int SkipList<K, V>::insert_element(const K key, const V value) &#123;     mtx.lock(); // 写操作，加锁    Node<K, V> *current = this->_header; // 从头节点遍历        // update 是一个指针数组，数组内存放指针，指向 node 节点，其索引代表层    Node<K, V> *update[_max_level + 1];  // update 的大小 >= forward    memset(update, 0, sizeof(Node<K, V>*)*(_max_level + 1)); // 初始化    // 从最高层开始遍历    for(int i = _skip_list_level; i >= 0; i--) &#123;        // 只要当前节点的下一节点非空，且 key 小于目标, 就会向后遍历        while(current->forward[i] != NULL && current->forward[i]->get_key() < key) &#123;            current = current->forward[i];  // 节点向后移动，这里你就把forward[i]理解为next就行        &#125;        update[i] = current;  // update[i] 记录当前层最后符合要求的节点    &#125;    // 遍历到 level 0 说明到达最底层了，forward[0]指向的就是跳表下一个邻近节点    current = current->forward[0];      // 注意此时 current->get_key() >= key !!!    // 1. 插入元素已经存在    if (current != NULL && current->get_key() == key) &#123;        std::cout << "key: " << key << ", exists" << std::endl;        mtx.unlock();        return -1;  // 插入元素已经存在，返回 -1，插入失败    &#125;    // 2. 如果当前 current 不存在，或者 current->get_key > key    if (current == NULL || current->get_key() != key ) &#123;        // 随机生成层的高度，也即 forward[] 大小        int random_level = get_random_level();                // 如果新添加的节点层高大于当前跳表层高，则需要更新 update 数组        // 将原本[_skip_list_level random_level]范围内的NULL改为_header        if (random_level > _skip_list_level) &#123;            for (int i = _skip_list_level + 1; i < random_level + 1; i++) &#123;                update[i] = _header;            &#125;            _skip_list_level = random_level; // 最后更新跳表层高        &#125;        // 创建节点，并进行插入操作        Node<K, V>* inserted_node = create_node(key, value, random_level);        // 该操作等价于:        // new_node->next = pre_node->next;         // pre_node->next = new_node; 只不过是逐层进行        for (int i = 0; i <= random_level; i++) &#123;            inserted_node->forward[i] = update[i]->forward[i];            update[i]->forward[i] = inserted_node;        &#125;        std::cout << "Successfully inserted key: " << key << ", value: " << value << std::endl;        _element_count ++;  // 更新节点数    &#125;    mtx.unlock();    return 0;  // 返回 0，插入成功&#125;</code></pre><pre class=" language-line-numbers language-markdown"><code class="language-line-numbers language-markdown">                           +------------+                           |  insert 50 |                           +------------+level 4     +-->1+                                                      100                 |                 |                      insert +----+level 3         1+-------->10+---------------> | 50 |          70       100                                               |    |                                               |    |level 2         1          10         30       | 50 |          70       100                                               |    |                                               |    |level 1         1    4     10         30       | 50 |          70       100                                               |    |                                               |    |level 0         1    4   9 10         30   40  | 50 |  60      70       100                                               +----+</code></pre><h4 id="2-4-5-delete-element"><a href="#2-4-5-delete-element" class="headerlink" title="2.4.5 delete_element()"></a>2.4.5 delete_element()</h4><p>将上面插入节点的步骤理解透彻，你就会觉得删除节点是很容易的，说白了，就是：</p><ul><li>先遍历得到要删除的层，然后对相应节点进行删除</li></ul><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">template<typename K, typename V> int SkipList<K, V>::delete_element(K key) &#123;    // 操作同 insert_element    mtx.lock();    Node<K, V> *current = this->_header;     Node<K, V> *update[_max_level + 1];    memset(update, 0, sizeof(Node<K, V>*)*(_max_level + 1));    for (int i = _skip_list_level; i >= 0; i--) &#123;        while (current->forward[i] !=NULL && current->forward[i]->get_key() < key) &#123;            current = current->forward[i];        &#125;        update[i] = current;    &#125;    current = current->forward[0];        // 1. 非空，且 key 为目标值    if (current != NULL && current->get_key() == key) &#123;          // 从最底层开始删除 update->forward 指向的节点，即目标节点        for (int i = 0; i <= _skip_list_level; i++) &#123;            // 如果 update[i] 已经不指向 current 说明 i 的上层也不会指向 current            // 也说明了被删除节点层高 i - 1。直接退出循环即可            if (update[i]->forward[i] != current)                 break;                                        // 删除操作，等价于 node->next = node->next->next            update[i]->forward[i] = current->forward[i];        &#125;        // 因为可能删除的元素它的层数恰好是当前跳跃表的最大层数        // 所以此时需要重新确定 _skip_list_level,通过头节点判断        while (_skip_list_level > 0 && _header->forward[_skip_list_level] == 0) &#123;            _skip_list_level --;         &#125;        std::cout << "Successfully deleted key : "<< key << std::endl;        _element_count --;        mtx.unlock();        return 0; // 返回值 0 说明成功删除    &#125;    // 2. 笔者添加了没有该键时的情况，打印输出提示    else &#123;        std::cout << key << " is not exist, please check your input !\n";        mtx.unlock();        return -1; // 返回值 -1 说明没有该键值    &#125; &#125;</code></pre><h4 id="2-4-6-search-element"><a href="#2-4-6-search-element" class="headerlink" title="2.4. 6 search_element()"></a>2.4. 6 search_element()</h4><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">template<typename K, typename V> bool SkipList<K, V>::search_element(K key) &#123;    std::cout << "search_element..." << std::endl;    Node<K, V> *current = _header;    // 从最高层开始遍历，找到最底层中最后一个满足小于key的节点    for (int i = _skip_list_level; i >= 0; i--) &#123;        while (current->forward[i] && current->forward[i]->get_key() < key) &#123;            current = current->forward[i];        &#125;    &#125;    current = current->forward[0]; // 该操作后 current->get_key >= key 或者 null    // 找到    if (current != NULL && current->get_key() == key) &#123;        std::cout << "Found key: " << key << ", value: " << current->get_value() << std::endl;        return true;    &#125;    // 没找到    std::cout << "Not Found Key: " << key << std::endl;    return false;&#125;</code></pre><h4 id="2-4-7-打印跳表"><a href="#2-4-7-打印跳表" class="headerlink" title="2.4.7 打印跳表"></a>2.4.7 打印跳表</h4><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">template<typename K, typename V> void SkipList<K, V>::display_list() &#123;    std::cout << "\n******** Skip List ********"<<"\n";     // 逐层打印    for (int i = 0; i <= _skip_list_level; i++) &#123;        Node<K, V> *node = this->_header->forward[i];         std::cout << "Level " << i << ": ";        while (node != NULL) &#123;            std::cout << node->get_key() << ":" << node->get_value() << ";";            node = node->forward[i];        &#125;        std::cout << std::endl;    &#125;&#125;</code></pre><h4 id="2-4-8-数据落盘、数据加载函数及其辅助函数"><a href="#2-4-8-数据落盘、数据加载函数及其辅助函数" class="headerlink" title="2.4.8 数据落盘、数据加载函数及其辅助函数"></a>2.4.8 数据落盘、数据加载函数及其辅助函数</h4><ul><li>这里<code>STORE_FILE</code>是我们预定义的文件落盘位置</li></ul><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">// Dump data in memory to file template<typename K, typename V> void SkipList<K, V>::dump_file() &#123;    std::cout << "dump_file..." << std::endl;    _file_writer.open(STORE_FILE);  // 打开文件，写操作    Node<K, V> *node = this->_header->forward[0];     // 只写入键值对，放弃层信息    while (node != NULL) &#123;        // 文件写入（key value 以 : 为分隔符），及信息打印        _file_writer << node->get_key() << ":" << node->get_value() << "\n";         std::cout << node->get_key() << ":" << node->get_value() << ";\n";           node = node->forward[0];    &#125;    _file_writer.flush();// 刷新    _file_writer.close();    return ;&#125;// Load data from disktemplate<typename K, typename V> void SkipList<K, V>::load_file() &#123;    _file_reader.open(STORE_FILE);  // 打开文件，读操作    std::cout << "load_file..." << std::endl;    std::string line;    // key 与 value 是一个指向 string 对象的指针    std::string* key = new std::string();    std::string* value = new std::string();    while (getline(_file_reader, line)) &#123; // 一行一行写入        get_key_value_from_string(line, key, value);  // 辅助函数        if (key->empty() || value->empty()) &#123;            continue;        &#125;        // 重新载入过程使用 insert_element()        // 所以层之间的关系(各节点的层高)可能发生变化, 所以与之前的SkipList不同        insert_element(*key, *value);          std::cout << "key:" << *key << "value:" << *value << std::endl;    &#125;    _file_reader.close();&#125;// 辅助函数template<typename K, typename V>void SkipList<K, V>::get_key_value_from_string(const std::string& str, std::string* key, std::string* value) &#123;    if(!is_valid_string(str)) &#123;        return;    &#125;    // 分隔符之前的为 key, 分隔符之后的为 value    *key = str.substr(0, str.find(delimiter));      *value = str.substr(str.find(delimiter) + 1, str.length()); &#125;template<typename K, typename V>bool SkipList<K, V>::is_valid_string(const std::string& str) &#123;    if (str.empty()) &#123;        return false;    &#125;    // 没有发现分隔符    if (str.find(delimiter) == std::string::npos) &#123;        return false;    &#125;    return true;&#125;</code></pre><h4 id="2-4-9-clear"><a href="#2-4-9-clear" class="headerlink" title="2.4.9 clear()"></a>2.4.9 clear()</h4><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">template<typename K, typename V> void SkipList<K, V>::clear() &#123;     std::cout << "clear ..." << std::endl;    Node<K, V> *node = this->_header->forward[0];     // 删除节点    while (node != NULL) &#123;        Node<K, V> *temp = node;        node = node->forward[0];        delete temp;    &#125;    // 重新初始化 _header    for (int i = 0; i <= _max_level; i++) &#123;        this->_header->forward[i] = 0;    &#125;    this->_skip_list_level = 0;    this->_element_count = 0;&#125;</code></pre><h2 id="3-项目测试"><a href="#3-项目测试" class="headerlink" title="3 项目测试"></a>3 项目测试</h2><h3 id="3-1-跳表-API-进行测试："><a href="#3-1-跳表-API-进行测试：" class="headerlink" title="3.1 跳表 API 进行测试："></a>3.1 跳表 <code>API</code> 进行测试：</h3><p>针对所有提供的 <code>API</code> 进行测试：</p><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">#include <iostream>#include "skiplist.h"#define FILE_PATH "./store/dumpFile"int main() &#123;    SkipList<std::string, std::string> skipList(5);    // insert 测试    std::cout << "--- insert 测试 ---" << std::endl;    skipList.insert_element("1", "one");     skipList.insert_element("2", "t");     skipList.insert_element("中文", " 测试2");     skipList.insert_element("english", "测试3");     std::cout << "skipList size after insert_element(): " << skipList.size() << std::endl; // 4     // search 测试    std::cout << "--- search 测试 ---" << std::endl;    skipList.search_element("3");    skipList.search_element("中文");    skipList.search_element("4");    // delete 测试    std::cout << "--- delete 测试 ---" << std::endl;    skipList.delete_element("3");  // 成功    skipList.delete_element("5");  // 失败    std::cout << "skipList size after delete_element(): " << skipList.size() << std::endl; // 4       // dump_file 测试    std::cout << "--- dump_file 测试 ---" << std::endl;    skipList.dump_file();    // display 测试    std::cout << "--- display 测试 ---" << std::endl;    skipList.display_list();        // clear 测试    std::cout << "--- clear 测试 ---" << std::endl;    skipList.clear();    std::cout << "skipList size after clear(): " << skipList.size() << std::endl; // 0    // load_file 测试    std::cout << "--- load_file 测试 ---" << std::endl;    skipList.load_file();    std::cout << "skipList size after load_file(): " << skipList.size() << std::endl; // 4    skipList.display_list();    return 0;&#125;</code></pre><p><strong>测试结果：</strong></p><p><img src="/2022/09/19/ji-yu-tiao-biao-shi-xian-de-jian-zhi-xing-cun-chu-yin-qing/image-20220919134316427.png" alt="image-20220919134316427"></p><p><img src="C:/Users/ASUS/AppData/Roaming/Typora/typora-user-images/image-20220919235514837.png" alt="image-20220919134357214"></p><p><img src="C:/Users/ASUS/AppData/Roaming/Typora/typora-user-images/image-20220919134431885.png" alt="image-20220919134431885"></p><h3 id="3-2-增删改查-QPS-测试"><a href="#3-2-增删改查-QPS-测试" class="headerlink" title="3.2 增删改查 QPS 测试"></a>3.2 增删改查 QPS 测试</h3><p>对增删改查进行测试。测试方法：设定固定的操作数，设置层高为 18，采用随机插入数据，看各个操作运行时间。</p><p>具体代码见：<code>stress-test/stress_test.cpp</code></p><p><strong>运行设备</strong> ：腾讯云服务器 2 核 2 G，系统 Centos 7.6</p><p><strong>运行结果</strong> ：</p><pre class=" language-line-numbers language-markdown"><code class="language-line-numbers language-markdown">TEST_COUNT : 1000000 NUM_THREADS: 1insert elapsed: 3.7795get elapsed: 4.2206</code></pre><p>以 100 w 数据结果计算 QPS:</p><p><strong>插入</strong> ：26.46 w</p><p><strong>取数据</strong>：23.7 w</p><p><strong>补充一些知识点：</strong></p><p>落盘：就是将数据写入到磁盘（存储介质）；<br>刷盘：并不是每次接收到数据后就将数据写入到磁盘，而是会先写入缓冲区，将缓冲区的数据写入到磁盘的过程，称为刷盘。<br>C++ 函数前面和后面 使用<code>const</code>的作用：</p><ul><li>前面使用<code>const</code>表示返回值为<code>const</code></li><li>后面加<code>const</code>表示函数不可以修改<code>class</code>的成员</li></ul><p><strong>参考文献：</strong></p><ul><li><p><a href="https://zhuanlan.zhihu.com/p/224575404">跳表原理</a></p></li><li><p><a href="https://github.com/youngyangyang04/Skiplist-CPP">Skiplist-CPP</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 面向对象的三大特性（1）</title>
      <link href="/2022/09/09/c-mian-xiang-dui-xiang-de-san-da-te-xing-1/"/>
      <url>/2022/09/09/c-mian-xiang-dui-xiang-de-san-da-te-xing-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gRPC介绍及安装</title>
      <link href="/2022/09/07/grpc-jie-shao-ji-an-zhuang/"/>
      <url>/2022/09/07/grpc-jie-shao-ji-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="gRPC介绍及安装"><a href="#gRPC介绍及安装" class="headerlink" title="gRPC介绍及安装"></a>gRPC介绍及安装</h1><p>此文章来自<a href="http://doc.oschina.net/grpc?t=56831">gRPC 官方文档中文版</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="http://www.oschina.net/p/grpc-framework">gRPC</a>  是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP&#x2F;2 设计。目前提供 C、Java 和 Go 语言版本，分别是：grpc, grpc-java, grpc-go. 其中 C 版本支持 C, C++, Node.js, Python, Ruby, Objective-C, PHP 和 C# 支持.</p><p>gRPC 基于 HTTP&#x2F;2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。</p><p>《gRPC 官方文档中文版》原文出自《 <a href="http://www.grpc.io/docs/">gRPC Docs</a>》，由多位网友在开源中国众包平台协作翻译完成，其中：</p><ul><li>Guides 部分由 <a href="http://my.oschina.net/altersoft">@sofeminer</a> 翻译</li><li>Tutorials 部分由 <a href="http://my.oschina.net/ivysummer">@马博文</a> 翻译</li><li>全部由 <a href="http://my.oschina.net/u/2350782">@jason0916</a> 校对</li></ul><h2 id="gRPC-是什么？"><a href="#gRPC-是什么？" class="headerlink" title="gRPC 是什么？"></a>gRPC 是什么？</h2><p>在 gRPC 里<em>客户端</em>应用可以像调用本地对象一样直接调用另一台不同的机器上<em>服务端</em>应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个<em>服务</em>，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个<em>存根</em>能够像服务端一样的方法。</p><p><img src="http://www.grpc.io/img/grpc_concept_diagram_00.png" alt="图1"></p><p>gRPC 客户端和服务端可以在多种环境中运行和交互 - 从 google 内部的服务器到你自己的笔记本，并且可以用任何 gRPC <a href="http://doc.oschina.net/grpc?t=58008#quickstart">支持的语言</a>来编写。所以，你可以很容易地用 Java 创建一个 gRPC 服务端，用 Go、Python、Ruby 来创建客户端。此外，Google 最新 API 将有 gRPC 版本的接口，使你很容易地将 Google 的功能集成到你的应用里。</p><h3 id="使用-protocol-buffers"><a href="#使用-protocol-buffers" class="headerlink" title="使用 protocol buffers"></a>使用 protocol buffers</h3><p>gRPC 默认使用 <em>protocol buffers</em>，这是 Google 开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如 JSON）。正如你将在下方例子里所看到的，你用 <em>proto files</em> 创建 gRPC 服务，用 protocol buffers 消息类型来定义方法参数和返回类型。你可以在 <a href="http://doc.oschina.net/https%EF%BC%9A//developers.google.com/protocol-buffers/docs/overview">Protocol Buffers 文档</a>找到更多关于 Protocol Buffers 的资料。</p><h4 id="Protocol-buffers-版本"><a href="#Protocol-buffers-版本" class="headerlink" title="Protocol buffers 版本"></a>Protocol buffers 版本</h4><p>尽管 protocol buffers 对于开源用户来说已经存在了一段时间，例子内使用的却一种名叫 proto3 的新风格的 protocol buffers，它拥有轻量简化的语法、一些有用的新功能，并且支持更多新语言。当前针对 Java 和 C++ 发布了 beta 版本，针对 JavaNano（即 Android Java）发布 alpha 版本，在<a href="http://doc.oschina.net/https%EF%BC%9A//github.com/google/protobuf/releases">protocol buffers Github 源码库里</a>有 Ruby 支持， 在<a href="http://doc.oschina.net/https%EF%BC%9A//github.com/golang/protobuf">golang&#x2F;protobuf Github 源码库</a>里还有针对 Go 语言的生成器， 对更多语言的支持正在开发中。 你可以在 <a href="http://doc.oschina.net/https%EF%BC%9A//developers.google.com/protocol-buffers/docs/proto3">proto3 语言指南</a>里找到更多内容， 在与当前默认版本的<a href="http://doc.oschina.net/https%EF%BC%9A//github.com/google/protobuf/releases">发布说明</a>比较，看到两者的主要不同点。更多关于 proto3 的文档很快就会出现。虽然你<em>可以</em>使用 proto2 (当前默认的 protocol buffers 版本)， 我们通常建议你在 gRPC 里使用 proto3，因为这样你可以使用 gRPC 支持全部范围的的语言，并且能避免 proto2 客户端与 proto3 服务端交互时出现的兼容性问题，反之亦然。</p><h2 id="你好-gRPC"><a href="#你好-gRPC" class="headerlink" title="你好 gRPC!"></a>你好 gRPC!</h2><p>现在你已经对 gRPC 有所了解，了解其工作机制最简单的方法是看一个简单的例子。 Hello World 将带领你创建一个简单的客户端——服务端应用，向你展示：</p><ul><li>通过一个 protocol buffers 模式，定义一个简单的带有 Hello World 方法的 RPC 服务。</li><li>用你最喜欢的语言(如果可用的话)来创建一个实现了这个接口的服务端。</li><li>用你最喜欢的(或者其他你愿意的)语言来访问你的服务端。</li></ul><p>这个例子完整的代码在我们 GitHub 源码库的 <code>examples</code> 目录下。 我们使用 Git 版本系统来进行源码管理，但是除了如何安装和运行一些 Git 命令外，你没必要知道其他关于 Git 的任何事情。 需要注意的是，并不是所有 gRPC 支持的语言都可以编写我们例子的服务端代码，比如 PHP 和 Objective-C 仅支持创建客户端。 比起针对于特定语言的复杂教程，这更像是一个介绍性的例子。你可以在本站找到更有深度的教程，gRPC 支持的语言的参考文档很快就会全部开放。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>本节解释了如何在你本机上准备好例子代码的运行环境。如果你只是想读一下例子，你可以直接到下一步。</p><h4 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h4><p>你可以从<a href="http://git-scm.com/download%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85">http://git-scm.com/download下载和安装</a> Git。安装好 Git 后，你应该能访问 git 命令行工具。你需要的主要命令如下：</p><ul><li>git clone … ： 从远程代码库克隆一份到本机。</li><li>git checkout … ： 检出一个特殊分支或一个标签版本的代码来改进。</li></ul><h4 id="安装-gRPC"><a href="#安装-gRPC" class="headerlink" title="安装 gRPC"></a>安装 gRPC</h4><p>针对你选择的语言构建和安装 gRPC 插件和相关工具，可以参照<a href="http://doc.oschina.net/grpc?t=58008#quickstart">快速开始</a>。 </p><ul><li>C++</li></ul><p>例子代码在 GitHub 源码库的 <code>examples</code> 目录。你可以运行如下命令克隆源码到本地：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ git clone https://github.com/grpc/grpc.git</code></pre>]]></content>
      
      
      <categories>
          
          <category> RPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gRPC </tag>
            
            <tag> 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gRPC基础（C++篇）</title>
      <link href="/2022/09/07/grpc-ji-chu-c-pian/"/>
      <url>/2022/09/07/grpc-ji-chu-c-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="gRPC基础：C"><a href="#gRPC基础：C" class="headerlink" title="gRPC基础：C++"></a>gRPC基础：C++</h1><p>本教程提供了C++程序员如何使用gRPC的指南。</p><p>此文章来自<a href="http://doc.oschina.net/grpc?t=56831">gRPC 官方文档中文版</a></p><p>通过学习教程中例子，你可以学会如何：</p><ul><li>在一个 .proto 文件内定义服务.</li><li>用 protocol buffer 编译器生成服务器和客户端代码.</li><li>使用 gRPC 的 C++ API 为你的服务实现一个简单的客户端和服务器.</li></ul><p>假设你已经阅读了<a href="http://doc.oschina.net/docs/index.html">概览</a>并且熟悉<a href="https://developers.google.com/protocol-buffers/docs/overview">protocol buffers</a>. 注意，教程中的例子使用的是 protocol buffers 语言的 proto3 版本，它目前只是 alpha 版：可以在<a href="https://developers.google.com/protocol-buffers/docs/proto3">proto3 语言指南</a>和 protocol buffers 的 Github 仓库的<a href="https://github.com/google/protobuf/releases">版本注释</a>发现更多关于新版本的内容.</p><p>这算不上是一个在 C++ 中使用 gRPC 的综合指南：以后会有更多的参考文档.</p><h2 id="为什么使用-gRPC"><a href="#为什么使用-gRPC" class="headerlink" title="为什么使用 gRPC?"></a>为什么使用 gRPC?</h2><p>我们的例子是一个简单的路由映射的应用，它允许客户端获取路由特性的信息，生成路由的总结，以及交互路由信息，如服务器和其他客户端的流量更新。</p><p>有了 gRPC， 我们可以一次性的在一个 .proto 文件中定义服务并使用任何支持它的语言去实现客户端和服务器，反过来，它们可以在各种环境中，从Google的服务器到你自己的平板电脑- gRPC 帮你解决了不同语言间通信的复杂性以及环境的不同.使用 protocol buffers 还能获得其他好处，包括高效的序列号，简单的 IDL 以及容易进行接口更新。</p><h2 id="例子代码和设置"><a href="#例子代码和设置" class="headerlink" title="例子代码和设置"></a>例子代码和设置</h2><p>教程的代码在这里 <a href="https://github.com/grpc/grpc/tree/%3C!--swig%EF%BF%BC0--%3E/examples/cpp/route_guide">grpc&#x2F;grpc&#x2F;examples&#x2F;cpp&#x2F;route_guide</a>. 要下载例子，通过运行下面的命令去克隆<code>grpc</code>代码库：</p><h2 id="例子代码和设置-1"><a href="#例子代码和设置-1" class="headerlink" title="例子代码和设置"></a>例子代码和设置</h2><p>教程的代码在这里 <a href="https://github.com/grpc/grpc/tree/%3C!--swig%EF%BF%BC1--%3E/examples/cpp/route_guide">grpc&#x2F;grpc&#x2F;examples&#x2F;cpp&#x2F;route_guide</a>. 要下载例子，通过运行下面的命令去克隆<code>grpc</code>代码库：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ git clone https://github.com/grpc/grpc.git</code></pre><p>改变当前的目录到<code>examples/cpp/route_guide</code>：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ cd examples/cpp/route_guide</code></pre><p>你还需要安装生成服务器和客户端的接口代码相关工具-如果你还没有安装的话，查看下面的设置指南<a href="http://doc.oschina.net/docs/installation/c.html"> C++快速开始指南</a>。</p><h2 id="定义服务"><a href="#定义服务" class="headerlink" title="定义服务"></a>定义服务</h2><p>我们的第一步(可以从<a href="http://doc.oschina.net/docs/index.html">概览</a>中得知)是使用 <a href="https://developers.google.com/protocol-buffers/docs/overview">protocol buffers</a>去定义 gRPC <em>service</em> 和方法 <em>request</em> 以及 <em>response</em> 的类型。你可以在<a href="https://github.com/grpc/grpc/blob/%3C!--swig%EF%BF%BC2--%3E/examples/protos/route_guide.proto"><code>examples/protos/route_guide.proto</code></a>看到完整的 .proto 文件。</p><p>要定义一个服务，你必须在你的 .proto 文件中指定 <code>service</code>：</p><pre class=" language-line-numbers language-cpp"><code class="language-line-numbers language-cpp">service RouteGuide &#123;   ...&#125;</code></pre><p>然后在你的服务中定义 <code>rpc</code> 方法，指定请求的和响应类型。gRPC允 许你定义4种类型的 service 方法，在 <code>RouteGuide</code> 服务中都有使用：</p><ul><li>一个 <em>简单 RPC</em> ， 客户端使用存根发送请求到服务器并等待响应返回，就像平常的函数调用一样。</li></ul><pre class=" language-line-numbers language-cpp"><code class="language-line-numbers language-cpp">   // Obtains the feature at a given position.   rpc GetFeature(Point) returns (Feature) &#123;&#125;</code></pre><ul><li>一个 <em>服务器端流式 RPC</em> ， 客户端发送请求到服务器，拿到一个流去读取返回的消息序列。 客户端读取返回的流，直到里面没有任何消息。从例子中可以看出，通过在 <em>响应</em> 类型前插入 <code>stream</code> 关键字，可以指定一个服务器端的流方法。</li></ul><pre class=" language-line-numbers language-cpp"><code class="language-line-numbers language-cpp">  // Obtains the Features available within the given Rectangle.  Results are  // streamed rather than returned at once (e.g. in a response message with a  // repeated field), as the rectangle may cover a large area and contain a  // huge number of features.  rpc ListFeatures(Rectangle) returns (stream Feature) &#123;&#125;</code></pre><ul><li>一个 <em>客户端流式 RPC</em> ， 客户端写入一个消息序列并将其发送到服务器，同样也是使用流。一旦客户端完成写入消息，它等待服务器完成读取返回它的响应。通过在 <em>请求</em> 类型前指定 <code>stream</code> 关键字来指定一个客户端的流方法。</li></ul><pre class=" language-line-numbers language-cpp"><code class="language-line-numbers language-cpp">  // Accepts a stream of Points on a route being traversed, returning a  // RouteSummary when traversal is completed.  rpc RecordRoute(stream Point) returns (RouteSummary) &#123;&#125;</code></pre><ul><li>一个 <em>双向流式 RPC</em> 是双方使用读写流去发送一个消息序列。两个流独立操作，因此客户端和服务器可以以任意喜欢的顺序读写：比如， 服务器可以在写入响应前等待接收所有的客户端消息，或者可以交替的读取和写入消息，或者其他读写的组合。 每个流中的消息顺序被预留。你可以通过在请求和响应前加 <code>stream</code> 关键字去制定方法的类型。</li></ul><pre><code>  // Accepts a stream of RouteNotes sent while a route is being traversed,  // while receiving other RouteNotes (e.g. from other users).  rpc RouteChat(stream RouteNote) returns (stream RouteNote) &#123;&#125;</code></pre><p>我们的 .proto 文件也包含了所有请求的 protocol buffer 消息类型定义以及在服务方法中使用的响应类型-比如，下面的<code>Point</code>消息类型：</p><pre><code>// Points are represented as latitude-longitude pairs in the E7 representation// (degrees multiplied by 10**7 and rounded to the nearest integer).// Latitudes should be in the range +/- 90 degrees and longitude should be in// the range +/- 180 degrees (inclusive).message Point &#123;  int32 latitude = 1;  int32 longitude = 2;&#125;</code></pre><h2 id="生成客户端和服务器端代码"><a href="#生成客户端和服务器端代码" class="headerlink" title="生成客户端和服务器端代码"></a>生成客户端和服务器端代码</h2><p>接下来我们需要从 .proto 的服务定义中生成 gRPC 客户端和服务器端的接口。我们通过 protocol buffer 的编译器 <code>protoc</code> 以及一个特殊的 gRPC C++ 插件来完成。</p><p>简单起见，我们提供一个 <a href="https://github.com/grpc/grpc/blob/%3C!--swig%EF%BF%BC3--%3E/examples/cpp/route_guide/Makefile">makefile</a> 帮您用合适的插件，输入，输出去运行 <code>protoc</code>(如果你想自己去运行，确保你已经安装了 protoc，并且请遵循下面的 gRPC 代码<a href="https://github.com/grpc/grpc/blob/%3C!--swig%EF%BF%BC4--%3E/INSTALL">安装指南</a>)来操作：</p><pre class=" language-line-numbers language-go"><code class="language-line-numbers language-go">$ make route_guide.grpc.pb.cc route_guide.pb.cc</code></pre><p>实际上运行的是：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ protoc -I ../../protos --grpc_out=. --plugin=protoc-gen-grpc=`which grpc_cpp_plugin` ../../protos/route_guide.proto$ protoc -I ../../protos --cpp_out=. ../../protos/route_guide.proto</code></pre><p>运行这个命令可以在当前目录中生成下面的文件：</p><ul><li><code>route_guide.pb.h</code>， 声明生成的消息类的头文件</li><li><code>route_guide.pb.cc</code>， 包含消息类的实现</li><li><code>route_guide.grpc.pb.h</code>， 声明你生成的服务类的头文件</li><li><code>route_guide.grpc.pb.cc</code>， 包含服务类的实现</li></ul><p>这些包括：</p><ul><li>所有的填充，序列化和获取我们请求和响应消息类型的 protocol buffer 代码</li><li>名为<code>RouteGuide</code>的类，包含<ul><li>为了客户端去调用定义在 <code>RouteGuide</code> 服务的远程接口类型(或者 <em>存根</em> )</li><li>让服务器去实现的两个抽象接口，同时包括定义在 <code>RouteGuide</code> 中的方法。</li></ul></li></ul><h2 id="创建服务器"><a href="#创建服务器" class="headerlink" title="创建服务器"></a>创建服务器</h2><p>首先来看看我们如何创建一个 <code>RouteGuide</code> 服务器。如果你只对创建 gRPC 客户端感兴趣，你可以跳过这个部分，直接到<a href="http://doc.oschina.net/grpc?t=57966#client">创建客户端</a> (当然你也可能发现它也很有意思)。</p><p>让 <code>RouteGuide</code> 服务工作有两个部分：</p><ul><li>实现我们服务定义的生成的服务接口：做我们的服务的实际的“工作”。</li><li>运行一个 gRPC 服务器，监听来自客户端的请求并返回服务的响应。</li></ul><p>你可以从<a href="https://github.com/grpc/grpc/blob/%3C!--swig%EF%BF%BC5--%3E/examples/cpp/route_guide/route_guide_server.cc">examples&#x2F;cpp&#x2F;route_guide&#x2F;route_guide_server.cc</a>看到我们的 <code>RouteGuide</code> 服务器的实现代码。现在让我们近距离研究它是如何工作的。</p><h3 id="实现RouteGuide"><a href="#实现RouteGuide" class="headerlink" title="实现RouteGuide"></a>实现RouteGuide</h3><p>我们可以看出，服务器有一个实现了生成的 <code>RouteGuide::Service</code> 接口的 <code>RouteGuideImpl</code> 类：</p><pre class=" language-line-numbers language-cpp"><code class="language-line-numbers language-cpp">class RouteGuideImpl final : public RouteGuide::Service &#123;...&#125;</code></pre><p>在这个场景下，我们正在实现 <em>同步</em> 版本的<code>RouteGuide</code>，它提供了 gRPC 服务器缺省的行为。同时，也有可能去实现一个异步的接口 <code>RouteGuide::AsyncService</code>，它允许你进一步定制服务器线程的行为，虽然在本教程中我们并不关注这点。</p><p><code>RouteGuideImpl</code> 实现了所有的服务方法。让我们先来看看最简单的类型 <code>GetFeature</code>，它从客户端拿到一个 <code>Point</code> 然后将对应的特性返回给数据库中的 <code>Feature</code>。</p><pre class=" language-line-numbers language-scss"><code class="language-line-numbers language-scss">  Status GetFeature(ServerContext* context, const Point* point,                    Feature* feature) override &#123;    feature->set_name(GetFeatureName(*point, feature_list_));    feature->mutable_location()——>CopyFrom(*point);    return Status::OK;  &#125;</code></pre><p>这个方法为 RPC 传递了一个上下文对象，包含了客户端的 <code>Point</code> protocol buffer 请求以及一个填充响应信息的<code>Feature</code> protocol buffer。在这个方法中，我们用适当的信息填充 <code>Feature</code>，然后返回<code>OK</code>的状态，告诉 gRPC 我们已经处理完 RPC，并且 <code>Feature</code> 可以返回给客户端。</p><p>现在让我们看看更加复杂点的情况——流式RPC。 <code>ListFeatures</code> 是一个服务器端的流式 RPC，因此我们需要给客户端返回多个 <code>Feature</code>。</p><pre class=" language-line-numbers language-rust"><code class="language-line-numbers language-rust">  Status ListFeatures(ServerContext* context, const Rectangle* rectangle,                      ServerWriter<Feature>* writer) override &#123;    auto lo = rectangle->lo();    auto hi = rectangle->hi();    long left = std::min(lo.longitude(), hi.longitude());    long right = std::max(lo.longitude(), hi.longitude());    long top = std::max(lo.latitude(), hi.latitude());    long bottom = std::min(lo.latitude(), hi.latitude());    for (const Feature& f : feature_list_) &#123;      if (f.location().longitude() >= left &&          f.location().longitude() <= right &&          f.location().latitude() >= bottom &&          f.location().latitude() <= top) &#123;        writer->Write(f);      &#125;    &#125;    return Status::OK;  &#125;</code></pre><p>如你所见，这次我们拿到了一个请求对象(客户端期望在 <code>Rectangle</code> 中找到的 <code>Feature</code>)以及一个特殊的 <code>ServerWriter</code> 对象，而不是在我们的方法参数中获取简单的请求和响应对象。在方法中，根据返回的需要填充足够多的 <code>Feature</code> 对象，用 <code>ServerWriter</code> 的 <code>Write()</code> 方法写入。最后，和我们简单的 RPC 例子相同，我们返回<code>Status::OK</code>去告知gRPC我们已经完成了响应的写入。</p><p>如果你看过客户端流方法<code>RecordRoute</code>，你会发现它很类似，除了这次我们拿到的是一个<code>ServerReader</code>而不是请求对象和单一的响应。我们使用 <code>ServerReader</code> 的 <code>Read()</code> 方法去重复的往请求对象(在这个场景下是一个 <code>Point</code>)读取客户端的请求直到没有更多的消息：在每次调用后，服务器需要检查 <code>Read()</code> 的返回值。如果返回值为 <code>true</code>，流仍然存在，它就可以继续读取；如果返回值为 <code>false</code>，则表明消息流已经停止。</p><pre class=" language-line-numbers language-bash"><code class="language-line-numbers language-bash">while (stream->Read(&point)) &#123;  ...//process client input&#125;</code></pre><p>最后，让我们看看双向流RPC<code>RouteChat()</code>。</p><pre class=" language-line-numbers language-cpp"><code class="language-line-numbers language-cpp">  Status RouteChat(ServerContext* context,                   ServerReaderWriter<RouteNote, RouteNote>* stream) override &#123;    std::vector<RouteNote> received_notes;    RouteNote note;    while (stream->Read(&note)) &#123;      for (const RouteNote& n : received_notes) &#123;        if (n.location().latitude() == note.location().latitude() &&            n.location().longitude() == note.location().longitude()) &#123;          stream->Write(n);        &#125;      &#125;      received_notes.push_back(note);    &#125;    return Status::OK;  &#125;</code></pre><p>这次我们得到的 <code>ServerReaderWriter</code> 对象可以用来读 <em>和</em> 写消息。这里读写的语法和我们客户端流以及服务器流方法是一样的。虽然每一端获取对方信息的顺序和写入的顺序一致，客户端和服务器都可以以任意顺序读写——流的操作是完全独立的。</p><h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><p>一旦我们实现了所有的方法，我们还需要启动一个gRPC服务器，这样客户端才可以使用服务。下面这段代码展示了在我们<code>RouteGuide</code>服务中实现的过程：</p><pre class=" language-line-numbers language-scss"><code class="language-line-numbers language-scss">void RunServer(const std::string& db_path) &#123;  std::string server_address("0.0.0.0:50051");  RouteGuideImpl service(db_path);  ServerBuilder builder;  builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());  builder.RegisterService(&service);  std::unique_ptr<Server> server(builder.BuildAndStart());  std::cout << "Server listening on " << server_address << std::endl;  server->Wait();&#125;</code></pre><p>如你所见，我们通过使用<code>ServerBuilder</code>去构建和启动服务器。为了做到这点，我们需要：</p><ol><li>创建我们的服务实现类 <code>RouteGuideImpl</code> 的一个实例。</li><li>创建工厂类 <code>ServerBuilder</code> 的一个实例。</li><li>在生成器的 <code>AddListeningPort()</code> 方法中指定客户端请求时监听的地址和端口。</li><li>用生成器注册我们的服务实现。</li><li>调用生成器的 <code>BuildAndStart()</code> 方法为我们的服务创建和启动一个RPC服务器。</li><li>调用服务器的 <code>Wait()</code> 方法实现阻塞等待，直到进程被杀死或者 <code>Shutdown()</code> 被调用。</li></ol><h2 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h2><p>在这部分，我们将尝试为<code>RouteGuide</code>服务创建一个C++的客户端。你可以从<a href="https://github.com/grpc/grpc/blob/%3C!--swig%EF%BF%BC6--%3E/examples/cpp/route_guide/route_guide_client.cc">examples&#x2F;cpp&#x2F;route_guide&#x2F;route_guide_client.cc</a>看到我们完整的客户端例子代码.</p><h3 id="创建一个存根"><a href="#创建一个存根" class="headerlink" title="创建一个存根"></a>创建一个存根</h3><p>为了能调用服务的方法，我们得先创建一个 <em>存根</em>。</p><p>首先需要为我们的存根创建一个gRPC <em>channel</em>，指定我们想连接的服务器地址和端口，以及 channel 相关的参数——在本例中我们使用了缺省的 <code>ChannelArguments</code> 并且没有使用SSL：</p><pre class=" language-line-numbers language-css"><code class="language-line-numbers language-css">grpc::CreateChannel("localhost:50051", grpc::InsecureCredentials(), ChannelArguments());</code></pre><p>现在我们可以利用channel，使用从.proto中生成的<code>RouteGuide</code>类提供的<code>NewStub</code>方法去创建存根。</p><pre class=" language-line-numbers language-php"><code class="language-line-numbers language-php"> public:  RouteGuideClient(std::shared_ptr<ChannelInterface> channel,                   const std::string& db)      : stub_(RouteGuide::NewStub(channel)) &#123;    ...  &#125;</code></pre><h3 id="调用服务的方法"><a href="#调用服务的方法" class="headerlink" title="调用服务的方法"></a>调用服务的方法</h3><p>现在我们来看看如何调用服务的方法。注意，在本教程中调用的方法，都是 <em>阻塞&#x2F;同步</em> 的版本：这意味着 RPC 调用会等待服务器响应，要么返回响应，要么引起一个异常。</p><h4 id="简单RPC"><a href="#简单RPC" class="headerlink" title="简单RPC"></a>简单RPC</h4><p>调用简单 RPC <code>GetFeature</code> 几乎是和调用一个本地方法一样直观。</p><pre class=" language-line-numbers language-cpp"><code class="language-line-numbers language-cpp">  Point point;  Feature feature;  point = MakePoint(409146138, -746188906);  GetOneFeature(point, &feature);...  bool GetOneFeature(const Point& point, Feature* feature) &#123;    ClientContext context;    Status status = stub_->GetFeature(&context, point, feature);    ...  &#125;</code></pre><p>如你所见，我们创建并且填充了一个请求的 protocol buffer 对象（例子中为 <code>Point</code>），同时为了服务器填写创建了一个响应 protocol buffer 对象。为了调用我们还创建了一个 <code>ClientContext</code> 对象——你可以随意的设置该对象上的配置的值，比如期限，虽然现在我们会使用缺省的设置。注意，你不能在不同的调用间重复使用这个对象。最后，我们在存根上调用这个方法，将其传给上下文，请求以及响应。如果方法的返回是<code>OK</code>，那么我们就可以从服务器从我们的响应对象中读取响应信息。</p><pre class=" language-line-numbers language-css"><code class="language-line-numbers language-css">      std:：cout << "Found feature called " << feature->name()  << " at "                << feature->location().latitude()/kCoordFactor_ << ", "                << feature->location().longitude()/kCoordFactor_ << std:：endl;</code></pre><h4 id="流式RPC"><a href="#流式RPC" class="headerlink" title="流式RPC"></a>流式RPC</h4><p>现在来看看我们的流方法。如果你已经读过<a href="http://doc.oschina.net/grpc?t=57966#server">创建服务器</a>，本节的一些内容看上去很熟悉——流式 RPC 是在客户端和服务器两端以一种类似的方式实现的。下面就是我们称作是服务器端的流方法 <code>ListFeatures</code>，它会返回地理的 <code>Feature</code>：</p><pre class=" language-line-numbers language-rust"><code class="language-line-numbers language-rust">    std::unique_ptr<ClientReader<Feature> > reader(        stub_->ListFeatures(&context, rect));    while (reader->Read(&feature)) &#123;      std::cout << "Found feature called "                << feature.name() << " at "                << feature.location().latitude()/kCoordFactor_ << ", "                << feature.location().longitude()/kCoordFactor_ << std::endl;    &#125;    Status status = reader->Finish();</code></pre><p>我们将上下文传给方法并且请求，得到 <code>ClientReader</code> 返回对象，而不是将上下文，请求和响应传给方法。客户端可以使用 <code>ClientReader</code> 去读取服务器的响应。我们使用 <code>ClientReader</code> 的 <code>Read()</code> 反复读取服务器的响应到一个响应 protocol buffer 对象(在这个例子中是一个 <code>Feature</code>)，直到没有更多的消息：客户端需要去检查每次调用完 <code>Read()</code> 方法的返回值。如果返回值为 <code>true</code>，流依然存在并且可以持续读取；如果是 <code>false</code>，说明消息流已经结束。最后，我们在流上调用 <code>Finish()</code> 方法结束调用并获取我们 RPC 的状态。</p><p>客户端的流方法 <code>RecordRoute</code> 的使用很相似，除了我们将一个上下文和响应对象传给方法，拿到一个 <code>ClientWriter</code> 返回。</p><pre class=" language-line-numbers language-rust"><code class="language-line-numbers language-rust">    std::unique_ptr<ClientWriter<Point> > writer(        stub_->RecordRoute(&context, &stats));    for (int i = 0; i < kPoints; i++) &#123;      const Feature& f = feature_list_[feature_distribution(generator)];      std::cout << "Visiting point "                << f.location().latitude()/kCoordFactor_ << ", "                << f.location().longitude()/kCoordFactor_ << std::endl;      if (!writer->Write(f.location())) &#123;        // Broken stream.        break;      &#125;      std::this_thread::sleep_for(std::chrono::milliseconds(          delay_distribution(generator)));    &#125;    writer->WritesDone();    Status status = writer->Finish();    if (status.IsOk()) &#123;      std::cout << "Finished trip with " << stats.point_count() << " points\n"                << "Passed " << stats.feature_count() << " features\n"                << "Travelled " << stats.distance() << " meters\n"                << "It took " << stats.elapsed_time() << " seconds"                << std::endl;    &#125; else &#123;      std::cout << "RecordRoute rpc failed." << std::endl;    &#125;</code></pre><p>一旦我们用 <code>Write()</code> 将客户端请求写入到流的动作完成，我们需要在流上调用 <code>WritesDone()</code> 通知 gRPC 我们已经完成写入，然后调用 <code>Finish()</code> 完成调用同时拿到 RPC 的状态。如果状态是 <code>OK</code>，我们最初传给 <code>RecordRoute()</code> 的响应对象会跟着服务器的响应被填充。</p><p>最后，让我们看看双向流式 RPC <code>RouteChat()</code>。在这种场景下，我们将上下文传给一个方法，拿到一个可以用来读写消息的<code>ClientReaderWriter</code>的返回。</p><pre class=" language-line-numbers language-css"><code class="language-line-numbers language-css">    std::shared_ptr<ClientReaderWriter<RouteNote, RouteNote> > stream(        stub_->RouteChat(&context));</code></pre><p>这里读写的语法和我们客户端流以及服务器端流方法没有任何区别。虽然每一方都能按照写入时的顺序拿到另一方的消息，客户端和服务器端都可以以任意顺序读写——流操作起来是完全独立的。</p><h2 id="来试试吧！"><a href="#来试试吧！" class="headerlink" title="来试试吧！"></a>来试试吧！</h2><p>构建客户端和服务器：</p><pre class=" language-line-numbers language-go"><code class="language-line-numbers language-go">$ make</code></pre><p>运行服务器，它会监听50051端口：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ ./route_guide_server</code></pre><p>在另外一个终端运行客户端：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ ./route_guide_client</code></pre>]]></content>
      
      
      <categories>
          
          <category> RPC </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gRPC </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试常考——C++11 新特性</title>
      <link href="/2022/09/06/mian-shi-chang-kao-c-11-xin-te-xing/"/>
      <url>/2022/09/06/mian-shi-chang-kao-c-11-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<h4 id="1、C-11有哪些新特性？"><a href="#1、C-11有哪些新特性？" class="headerlink" title="1、C++11有哪些新特性？"></a>1、C++11有哪些新特性？</h4><p>C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：</p><p>一、语法的改进</p><ol><li>统一的初始化方法———使用初始化列表进行初始化（适用性被增加，现可以用于任何类型对象的初始化）</li><li>成员变量默认初始化</li><li>auto 关键字 用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）</li><li>decltype 求表达式的类型</li><li>智能指针 shared_ptr</li><li>空指针 nullptr（原来NULL）</li><li>基于范围的 for 循环</li><li>右值引用和 move 语义 让程序员有意识减少进行深拷贝操作</li></ol><p>二、标准库扩充</p><ol><li>无序容器（哈希表） 用法和功能同 map 一模一样，区别在于哈希表的效率更高</li><li>正则表达式 可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串</li><li>Lambda 表达式</li></ol><h4 id="2、说一说你了解的关于lambda函数的全部知识"><a href="#2、说一说你了解的关于lambda函数的全部知识" class="headerlink" title="2、说一说你了解的关于lambda函数的全部知识"></a>2、说一说你了解的关于lambda函数的全部知识</h4><ul><li>① <strong>利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；</strong></li><li>② <strong>每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。</strong>那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。</li><li>③ lambda表达式的语法定义如下：<code>[capture] (parameters) mutable -&gt;return-type &#123;statement&#125;;</code></li><li>④ 与普通函数不同，lambda必须使用尾置返回来指定返回类型</li><li>⑤ 我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体</li></ul><h4 id="3、C-中NULL和nullptr区别"><a href="#3、C-中NULL和nullptr区别" class="headerlink" title="3、C++中NULL和nullptr区别"></a>3、<strong>C++中NULL和nullptr区别</strong></h4><p><strong>在C++中指针必须有明确的类型定义。但是将NULL定义为0带来的另一个问题是无法与整数的0区分。</strong></p><p>由于在<strong>传入NULL参数时，会把NULL当做整数0来看，如果我们想调用参数是指针的函数</strong>，该怎么办呢?nullptr在C++11被引入用于解决这一问题，<strong>nullptr可以明确区分整型和指针类型</strong>，<strong>能够根据环境自动转换成相应的指针类型</strong>，但不会被转换为任何整型，所以不会造成参数传递错误。</p><h4 id="4、auto、decltype和decltype-auto-的用法"><a href="#4、auto、decltype和decltype-auto-的用法" class="headerlink" title="4、auto、decltype和decltype(auto)的用法"></a>4、auto、decltype和decltype(auto)的用法</h4><p>1）auto </p><p><strong>auto用于定义变量，编译器可以自动判断变量的类型。auto 让编译器通过初始值来进行类型推演</strong>。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。</p><p><strong>auto和 const 的结合使用</strong></p><p>a. 当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性；</p><p>b. 当类型为引用时，auto 的推导结果将保留表达式的 const 属性。</p><p>使用auto定义迭代器比较方便</p><p>2）decltype</p><p>有的时候我们还会遇到这种情况，我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。还有可能是<strong>函数的返回类型为某表达式的值类型</strong>。在这些时候auto显得就无力了，所以C++11又引入了第二种类型说明符<strong>decltype，它的作用是选择并返回操作数的数据类型。</strong>在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。</p><p>3）decltype(auto)</p><p>decltype(auto)是C++14新增的类型指示符，<strong>可以用来声明变量以及指示函数返回类型</strong>。在使用时，会将“&#x3D;”号左边的表达式替换掉auto，再根据decltype的语法规则来确定类型。</p><h4 id="5、说说-C-中智能指针和指针的区别是什么？"><a href="#5、说说-C-中智能指针和指针的区别是什么？" class="headerlink" title="5、说说 C++ 中智能指针和指针的区别是什么？"></a>5、<strong>说说 C++ 中智能指针和指针的区别是什么？</strong></h4><p>智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。</p><h4 id="6、说说C-中的智能指针有哪些？分别解决的问题以及区别？"><a href="#6、说说C-中的智能指针有哪些？分别解决的问题以及区别？" class="headerlink" title="6、说说C++中的智能指针有哪些？分别解决的问题以及区别？"></a>6、说说C++中的智能指针有哪些？分别解决的问题以及区别？</h4><ol><li><p>C++中的智能指针有4种，分别为：shared_ptr、unique_ptr、weak_ptr、auto_ptr，其中，auto_ptr被C++11弃用。</p></li><li><p>使用智能指针的原因</p></li></ol><ul><li>申请的空间（即new出来的空间），在使用结束时，需要delete掉，否则会形成内存碎片。在程序运行期间，new出来的对象，在析构函数中delete掉，但是这种方法不能解决所有问题，因为有时候new发生在某个全局函数里面，该方法会给程序员造成精神负担。此时，智能指针就派上了用场。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以，智能指针的作用原理就是在函数结束时自动释放内存空间，避免了手动释放内存空间。</li></ul><ol start="3"><li>四种指针分别解决的问题以及各自特性如下：</li></ol><p>（1）auto_ptr（C++98的方案，C++11已经弃用）</p><ul><li>采用所有权模式。</li></ul><p>（2）unique_ptr（替换auto_ptr）</p><ul><li>unique_ptr实现独占式拥有或严格拥有概念，<strong>保证同一时间内只有一个智能指针可以指向该对象</strong>。它对于避免资源泄露，例如，以new创建对象后因为发生异常而忘记调用delete时的情形特别有用。</li></ul><p>（3）shared_ptr（非常好使）</p><ul><li>shared_ptr实现共享式拥有概念。<strong>多个智能指针可以指向相同对象</strong>，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</li></ul><p>（4）weak_ptr</p><ul><li>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr。weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用计数的增加或减少。<strong>weak_ptr是用来解决shared_ptr相互引用时的死锁问题</strong>，<strong>如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。</strong>它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化。shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</li></ul><h4 id="7、使用智能指针管理内存资源，RAII是怎么回事？"><a href="#7、使用智能指针管理内存资源，RAII是怎么回事？" class="headerlink" title="7、使用智能指针管理内存资源，RAII是怎么回事？"></a>7、<strong>使用智能指针管理内存资源，RAII是怎么回事？</strong></h4><p>① RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。</p><p>因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。</p><p>② 智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。</p><p>毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。</p><h4 id="8、智能指针的作用"><a href="#8、智能指针的作用" class="headerlink" title="8、智能指针的作用"></a>8、<strong>智能指针的作用</strong></h4><p>C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。</p><p><strong>初始化。智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化</strong>。也可以使用make_shared函数初始化。<strong>不能将指针直接赋值给一个智能指针，一个是类，一个是指针。</strong>例如std::shared_ptr<int> p4 &#x3D; new int(1);的写法是错误的</int></p><p><strong>拷贝和赋值。拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1</strong>，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象</p><p><strong>unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）</strong>。相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。</p><p>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, <strong>它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少</strong>。</p><h4 id="9、智能指针的循环引用"><a href="#9、智能指针的循环引用" class="headerlink" title="9、智能指针的循环引用"></a>9、<strong>智能指针的循环引用</strong></h4><p>循环引用是指使用多个智能指针share_ptr时，出现了指针之间相互指向，从而形成环的情况，有点类似于死锁的情况，这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。</p><p>在实际编程过程中，应该尽量避免出现智能指针之前相互指向的情况，如果不可避免，可以使用使用弱指针——weak_ptr，它不增加引用计数，只要出了作用域就会自动析构。</p><h4 id="10、智能指针出现循环引用怎么解决？"><a href="#10、智能指针出现循环引用怎么解决？" class="headerlink" title="10、智能指针出现循环引用怎么解决？"></a>10、<strong>智能指针出现循环引用怎么解决？</strong></h4><p>为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但是不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p><h4 id="11、-share-ptr-怎么知道跟它共享对象的指针释放了"><a href="#11、-share-ptr-怎么知道跟它共享对象的指针释放了" class="headerlink" title="11、**share_**ptr 怎么知道跟它共享对象的指针释放了"></a>11、**share_**<strong>ptr</strong> <strong>怎么知道跟它共享对象的指针释放了</strong></h4><p>多个shared_ptr对象可以同时托管一个指针，系统会维护一个托管计数。当无shared_ptr托管该指针时，delete该指针。</p><h4 id="12、手写实现智能指针类需要实现哪些函数？"><a href="#12、手写实现智能指针类需要实现哪些函数？" class="headerlink" title="12、手写实现智能指针类需要实现哪些函数？"></a>12、<strong>手写实现智能指针类需要实现哪些函数？</strong></h4><p>智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。它会自动记录SmartPointer&lt;T*&gt;对象的引用计数，一旦T类型对象的引用计数为0，就释放该对象。</p><p>除了指针对象外，我们还需要一个引用计数的指针设定对象的值，并将引用计数计为1，需要一个构造函数。新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。</p><p>通过<strong>覆写赋值运算符</strong>，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1</p><p><strong>一个构造函数、拷贝构造函数、复制构造函数、析构函数、移动函数；</strong></p><h4 id="13、-weak-ptr-能不能知道对象计数为-0，为什么？"><a href="#13、-weak-ptr-能不能知道对象计数为-0，为什么？" class="headerlink" title="13、**weak_**ptr 能不能知道对象计数为 0，为什么？"></a>13、**weak_**<strong>ptr</strong> <strong>能不能知道对象计数为 0，为什么？</strong></h4><p>不能。</p><p>weak_ptr是一种不控制对象生命周期的智能指针，它指向一个shared_ptr管理的对象。进行该对象管理的是那个引用的shared_ptr。weak_ptr只是提供了对管理 对象的一个访问手段。weak_ptr设计的目的只是为了配合shared_ptr而引入的一种智能指针，配合shared_ptr工作，它只可以从一个shared_ptr或者另一个weak_ptr对象构造，<strong>它的构造和析构不会引起计数的增加或减少。</strong></p><h4 id="14、请你回答一下智能指针有没有内存泄露的情况"><a href="#14、请你回答一下智能指针有没有内存泄露的情况" class="headerlink" title="14、请你回答一下智能指针有没有内存泄露的情况"></a>14、<strong>请你回答一下智能指针有没有内存泄露的情况</strong></h4><p><strong>智能指针有内存泄露的情况发生。</strong></p><ol><li><p>智能指针发生内存泄露的情况</p><ul><li>当两个对象同时使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄露。</li></ul></li><li><p>智能指针的内存泄漏如何解决？</p><ul><li>为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但是不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问。</li></ul></li></ol><h4 id="15、说说你了解的auto-ptr作用"><a href="#15、说说你了解的auto-ptr作用" class="headerlink" title="15、说说你了解的auto_ptr作用"></a>15、<strong>说说你了解的auto_ptr作用</strong></h4><p>auto_ptr的出现，主要是为了解决“<strong>有异常抛出时发生内存泄漏</strong>”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏；</p><p>auto_ptr的构造函数是explicit，阻止了一般指针隐式转换为 auto_ptr的构造，所以不能直接将一般类型的指针赋值给auto_ptr类型的对象，必须用auto_ptr的构造函数创建对象；</p><p>由于auto_ptr对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同一个指针；</p><p>auto_ptr内部实现，析构函数中删除对象用的是delete而不是delete[]，所以auto_ptr不能管理数组；</p><p>auto_ptr支持所拥有的指针类型之间的隐式类型转换。</p><p>可以通过*和-&gt;运算符对auto_ptr所有用的指针进行提领操作；</p><p>T* get(),获得auto_ptr所拥有的指针；T* release()，释放auto_ptr的所有权，并将所有用的指针返回。</p><h4 id="16、简述-C-右值引用与转移语义"><a href="#16、简述-C-右值引用与转移语义" class="headerlink" title="16、简述 C++ 右值引用与转移语义"></a>16、<strong>简述 C++ 右值引用与转移语义</strong></h4><ol><li>右值引用</li></ol><p>一般来说，不能取地址的表达式，就是右值引用，能取地址的，就是左值。</p><ol start="2"><li>转移语义</li></ol><p>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。基于 move() 函数特殊的功能，其常用于实现移动语义。</p><h4 id="17、说一下C-左值引用和右值引用"><a href="#17、说一下C-左值引用和右值引用" class="headerlink" title="17、说一下C++左值引用和右值引用"></a>17、<strong>说一下C++左值引用和右值引用</strong></h4><p>C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）。</p><p>① 在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。</p><p>② C++11对C++98中的右值进行了扩充。在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。其中<strong>纯右值</strong>的概念等同于我们在C++98标准中右值的概念，<strong>指的是临时变量和不跟对象关联的字面量值</strong>；<strong>将亡值则是C++11新增的跟右值引用相关的表达式</strong>，这样表达式通常是<strong>将要被移动的对象</strong>（移为他用），比如返回右值引用T&amp;&amp;的函数返回值、std::move的返回值，或者转换为T&amp;&amp;的类型转换函数的返回值。</p><p>③ 左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于<strong>右值通常不具有名字</strong>，我们也只能通过引用的方式找到它的存在。右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。</p><p>④ 右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。</p><p><strong>左值和右值</strong></p><p>左值：表示的是可以获取地址的表达式，它能出现在赋值语句的左边，对该表达式进行赋值。但是修饰符const的出现使得可以声明如下的标识符，它可以取得地址，但是没办法对其进行赋值</p><p>右值：表示无法获取地址的对象，有常量值、函数返回值、lambda表达式等。无法获取地址，但不表示其不可改变，当定义了右值的右值引用时就可以更改右值。</p><p><strong>左值引用和右值引用</strong></p><p>左值引用：传统的C++中引用被称为左值引用</p><p>右值引用：C++11中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置</p><p>这里主要说一下右值引用的特点：</p><p>特点1：通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去</p><p>特点2：右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值</p><p>特点3：T&amp;&amp; t在发生自动类型推断的时候，它是左值还是右值取决于它的初始化。</p><h4 id="18、简述一下-C-11-中四种类型转换"><a href="#18、简述一下-C-11-中四种类型转换" class="headerlink" title="18、简述一下 C++11 中四种类型转换"></a>18、<strong>简述一下 C++11 中四种类型转换</strong></h4><p>C++中四种类型转换分别为const_cast、static_cast、dynamic_cast、reinterpret_cast。</p><p><strong>1. const_cast</strong></p><p>将const变量转为非const</p><p><strong>2. static_cast</strong></p><p>最常用，可以用于各种隐式转换，比如非const转const，static_cast可以用于类向上转换，但向下转换能成功但是不安全。</p><p><strong>3. dynamic_cast</strong></p><p><strong>只能用于含有虚函数的类转换，用于类向上和向下转换</strong></p><p>向上转换：指子类向基类转换。</p><p>向下转换：指基类向子类转换。</p><p>这两种转换，子类包含父类，当父类转换成子类时可能出现非法内存访问的问题。</p><p><strong>dynamic_cast通过判断变量运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</strong>dynamic_cast可以做类之间上下转换，转换的时候会进行类型检查，类型相等成功转换，类型不等转换失败。运用RTTI技术，RTTI是”Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法。在c++层面主要体现在dynamic_cast和typeid，vs中虚函数表的-1位置存放了指向type_info的指针，对于存在虚函数的类型，dynamic_cast和typeid都会去查询type_info。</p><p><strong>4. reinterpret_cast</strong></p><p><strong>reinterpret_cast可以做任何类型的转换，不过不对转换结果保证，容易出问题。</strong></p><p>注意：为什么不用C的强制转换：C的强制转换表面上看起来功能强大什么都能转，但是转换不够明确，不能进行错误检查，容易出错。</p><h4 id="19、简述一下-C-11-中的可变参数模板新特性"><a href="#19、简述一下-C-11-中的可变参数模板新特性" class="headerlink" title="19、简述一下 C++11 中的可变参数模板新特性"></a>19、<strong>简述一下 C++11 中的可变参数模板新特性</strong></h4><p>可变参数模板(variadic template)使得编程者能够创建可接受可变数量的参数模板类。</p><p>要创建可变参数模板，需要理解几个要点：</p><p>（1）模板参数包（parameter pack）；</p><p>（2）函数参数包；</p><p>（3）展开（unpack）参数包；</p><p>（4）递归。</p><h4 id="20、static-cast比C语言中的转换强在哪里？"><a href="#20、static-cast比C语言中的转换强在哪里？" class="headerlink" title="20、static_cast比C语言中的转换强在哪里？"></a>20、static_cast比C语言中的转换强在哪里？</h4><p>更加安全；</p><p>更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；可清楚地辨别代码中每个显式的强制转；可读性更好，能体现程序员的意图。</p><p>公众号：写Bug那些事</p><p><a href="https://blog.csdn.net/CltCj?type=blog">我的CSDN</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试宝典 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器及使用</title>
      <link href="/2022/09/05/docker-rong-qi-ji-shi-yong/"/>
      <url>/2022/09/05/docker-rong-qi-ji-shi-yong/</url>
      
        <content type="html"><![CDATA[<h3 id="Docker-容器使用"><a href="#Docker-容器使用" class="headerlink" title="Docker 容器使用"></a>Docker 容器使用</h3><hr><h4 id="Docker-客户端"><a href="#Docker-客户端" class="headerlink" title="Docker 客户端"></a>Docker 客户端</h4><p>docker 客户端非常简单 ,我们可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker</code></pre><p><img src="/2022/09/05/docker-rong-qi-ji-shi-yong/image-20220905171048227.png" alt="image-20220905171048227"></p><p>可以通过命令 <strong>docker command –help</strong> 更深入的了解指定的 Docker 命令使用方法。</p><p>例如我们要查看 <strong>docker stats</strong> 指令的具体使用方法：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~# docker stats --help</code></pre><p><img src="/2022/09/05/docker-rong-qi-ji-shi-yong/image-20220905171157824.png" alt="image-20220905171157824"></p><p><img src="/2022/09/05/docker-rong-qi-ji-shi-yong/image-20220905170853523.png" alt="image-20220905170853523"></p><h3 id="容器使用"><a href="#容器使用" class="headerlink" title="容器使用"></a>容器使用</h3><h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><p>如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ docker pull ubuntu</code></pre><p>有的人可能会出现下面问题：</p><p><img src="/2022/09/05/docker-rong-qi-ji-shi-yong/image-20220905171438666.png" alt="image-20220905171438666"></p><p>这是你没有给非root用户权限运行docker，具体参考<a href="https://cltcj.github.io/2022/09/04/docker-jie-shao-ji-an-zhuang/">Docker介绍及安装</a></p><p>当然你也可以直接使用root进行操作：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ sudo docker pull ubuntu</code></pre><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><p>以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ docker run -it ubuntu /bin/bash</code></pre><p>参数说明：</p><ul><li><strong>-i</strong>: 交互式操作。</li><li><strong>-t</strong>: 终端。</li><li><strong>ubuntu</strong>: ubuntu 镜像。</li><li><strong>&#x2F;bin&#x2F;bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash。</li></ul><p>要退出终端，直接输入 <strong>exit</strong>:</p><p>要退出终端，直接输入 <strong>exit</strong>:</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">root@88867067c9dc:/# exit</code></pre><h4 id="启动已止运行的容器"><a href="#启动已止运行的容器" class="headerlink" title="启动已止运行的容器"></a>启动已止运行的容器</h4><p>查看所有的容器命令如下：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ docker ps -a</code></pre><p>使用 docker start 启动一个已停止的容器：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ sudo docker start 88867067c9dc</code></pre><p><img src="/2022/09/05/docker-rong-qi-ji-shi-yong/image-20220905175424186.png" alt="image-20220905175424186"></p><h4 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h4><p>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 <strong>-d</strong> 指定容器的运行模式。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ docker run -itd --name ubuntu-test ubuntu /bin/bash</code></pre><p><strong>注：</strong>加了 <strong>-d</strong> 参数默认不会进入容器，想要进入容器需要使用指令 <strong>docker exec</strong>（下面会介绍到）。</p><h4 id="停止一个容器"><a href="#停止一个容器" class="headerlink" title="停止一个容器"></a>停止一个容器</h4><p>停止容器的命令如下：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ docker stop <容器 ID></code></pre><p>停止的容器可以通过 docker restart 重启：</p><pre><code>$ docker restart &lt;容器 ID&gt;</code></pre><h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><p>在使用 <strong>-d</strong> 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p><ul><li><strong>docker attach</strong></li><li><strong>docker exec</strong>：推荐大家使用 docker exec 命令，因为此命令会退出容器终端，但不会导致容器的停止。</li></ul><p><strong>attach 命令</strong></p><p>下面演示了使用 docker attach 命令。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ sudo docker attach 88867067c9dc</code></pre><p><img src="/2022/09/05/docker-rong-qi-ji-shi-yong/image-20220905175635760.png" alt="image-20220905175635760"></p><p><strong>注意：</strong> 如果从这个容器退出，会导致容器的停止。</p><p><strong>exec 命令</strong></p><p>下面演示了使用 docker exec 命令。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">docker exec -it 88867067c9dc /bin/bash</code></pre><p><strong>注意：</strong> 如果从这个容器退出，容器不会停止，这就是为什么推荐大家使用 <strong>docker exec</strong> 的原因。</p><p>更多参数说明请使用 <strong>docker exec –help</strong> 命令查看。</p><h4 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h4><p><strong>导出容器</strong></p><p>如果要导出本地某个容器，可以使用 <strong>docker export</strong> 命令。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ docker export 88867067c9dc > ubuntu.tar</code></pre><p>导出容器 88867067c9dc 快照到本地文件 ubuntu.tar。</p><p>这样将导出容器快照到本地文件。</p><h4 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a><strong>导入容器快照</strong></h4><p>可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test&#x2F;ubuntu:v1:</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ cat docker/ubuntu.tar | docker import - test/ubuntu:v1</code></pre><p>此外，也可以通过指定 URL 或者某个目录来导入，例如：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ docker import http://example.com/exampleimage.tgz example/imagerepo</code></pre><h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p>删除容器使用 <strong>docker rm</strong> 命令：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ docker rm -f 88867067c9dc</code></pre><p>下面的命令可以清理掉所有处于终止状态的容器。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">$ docker container prune</code></pre><h3 id="web容器"><a href="#web容器" class="headerlink" title="web容器"></a>web容器</h3><h4 id="运行一个-web-应用"><a href="#运行一个-web-应用" class="headerlink" title="运行一个 web 应用"></a>运行一个 web 应用</h4><p>前面我们运行的容器并没有一些什么特别的用处。</p><p>接下来让我们尝试使用 docker 构建一个 web 应用程序。</p><p>我们将在docker容器中运行一个 Python Flask 应用来运行一个web应用。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker pull training/webapp # 载入镜像clt@clt-virtual-machine:~$ docker run -d -P training/webapp python app.py</code></pre><p><img src="/2022/09/05/docker-rong-qi-ji-shi-yong/image-20220906105844272.png" alt="image-20220906105844272"></p><p>参数说明:</p><ul><li>**-d:**让容器在后台运行。</li><li>**-P:**将容器内部使用的网络端口随机映射到我们使用的主机上。</li></ul><hr><h4 id="查看-WEB-应用容器"><a href="#查看-WEB-应用容器" class="headerlink" title="查看 WEB 应用容器"></a>查看 WEB 应用容器</h4><p>使用 docker ps 来查看我们正在运行的容器：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker psCONTAINER ID   IMAGE             COMMAND           CREATED         STATUS         PORTS                                         NAMES9a31ee6f1f19   training/webapp   "python app.py"   5 minutes ago   Up 4 minutes   0.0.0.0:49153->5000/tcp, :::49153->5000/tcp   affectionate_edisonc781f5452024   ubuntu:15.10      "/bin/bash"       5 minutes ago   Up 5 minutes                                                 compassionate_kirch</code></pre><p>这里多了端口信息。</p><pre><code>PORTS0.0.0.0:49153-&gt;5000/tcp</code></pre><p>Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 49153上。</p><p>这时我们可以通过浏览器访问WEB应用</p><p><img src="/2022/09/05/docker-rong-qi-ji-shi-yong/image-20220906113005395.png" alt="image-20220906113005395"></p><p>我们也可以通过 -p 参数来设置不一样的端口：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker run -d -p 5000:5000 training/webapp python app.py</code></pre><p><strong>docker ps</strong>查看正在运行的容器</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker psCONTAINER ID   IMAGE             COMMAND           CREATED              STATUS              PORTS                                         NAMESa9f76eee97ee   training/webapp   "python app.py"   About a minute ago   Up About a minute   0.0.0.0:5000->5000/tcp, :::5000->5000/tcp     quizzical_kirch9a31ee6f1f19   training/webapp   "python app.py"   35 minutes ago       Up 34 minutes       0.0.0.0:49153->5000/tcp, :::49153->5000/tcp   affectionate_edisonc781f5452024   ubuntu:15.10      "/bin/bash"       35 minutes ago       Up 35 minutes                                                     compassionate_kirch</code></pre><p>容器内部的 5000 端口映射到我们本地主机的 5000 端口上。</p><h4 id="网络端口的快捷方式"><a href="#网络端口的快捷方式" class="headerlink" title="网络端口的快捷方式"></a>网络端口的快捷方式</h4><p>通过 <strong>docker ps</strong> 命令可以查看到容器的端口映射，<strong>docker</strong> 还提供了另一个快捷方式 <strong>docker port</strong>，使用 <strong>docker port</strong> 可以查看指定 （ID 或者名字）容器的某个确定端口映射到宿主机的端口号。</p><p>上面我们创建的 web 应用容器 ID 为 <strong>a9f76eee97ee</strong> 名字为 <strong>quizzical_kirch</strong>。</p><p>我可以使用 <strong>docker port a9f76eee97ee</strong> 或 <strong>docker port quizzical_kirch</strong> 来查看容器端口的映射情况。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker port a9f76eee97ee5000/tcp -> 0.0.0.0:50005000/tcp -> :::5000clt@clt-virtual-machine:~$ docker port quizzical_kirch5000/tcp -> 0.0.0.0:50005000/tcp -> :::5000</code></pre><h4 id="查看-WEB-应用程序日志"><a href="#查看-WEB-应用程序日志" class="headerlink" title="查看 WEB 应用程序日志"></a>查看 WEB 应用程序日志</h4><p>docker logs [ID或者名字] 可以查看容器内部的标准输出。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker logs -f a9f76eee97ee * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)172.17.0.1 - - [06/Sep/2022 03:38:40] "GET / HTTP/1.1" 200 -172.17.0.1 - - [06/Sep/2022 03:38:40] "GET /favicon.ico HTTP/1.1" 404 -</code></pre><p><strong>-f:</strong> 让 <strong>docker logs</strong> 像使用 <strong>tail -f</strong> 一样来输出容器内部的标准输出。</p><p>从上面，我们可以看到应用程序使用的是 5000 端口并且能够查看到应用程序的访问日志。</p><h4 id="查看WEB应用程序容器的进程"><a href="#查看WEB应用程序容器的进程" class="headerlink" title="查看WEB应用程序容器的进程"></a>查看WEB应用程序容器的进程</h4><p>我们还可以使用 docker top 来查看容器内部运行的进程</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker top quizzical_kirchUID                 PID                 PPID                C                   STIME               TTY                 TIME                CMDroot                6059                6037                0                   11:31               ?                   00:00:01            python app.py</code></pre><hr><h4 id="检查-WEB-应用程序"><a href="#检查-WEB-应用程序" class="headerlink" title="检查 WEB 应用程序"></a>检查 WEB 应用程序</h4><p>使用 <strong>docker inspect</strong> 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker inspect quizzical_kirch[    &#123;        "Id": "a9f76eee97ee32e2c6144720f28bc3eee949e0e0ad1caa34d98f0cbb7b83d2ff",        "Created": "2022-09-06T03:31:13.836472995Z",        "Path": "python",        "Args": [            "app.py"        ],        "State": &#123;            "Status": "running",            "Running": true,            "Paused": false,            "Restarting": false,            "OOMKilled": false,            "Dead": false,            "Pid": 6059,            "ExitCode": 0,            "Error": "",            "StartedAt": "2022-09-06T03:31:22.336312232Z",            "FinishedAt": "0001-01-01T00:00:00Z"        &#125;,...</code></pre><h4 id="停止-WEB-应用容器"><a href="#停止-WEB-应用容器" class="headerlink" title="停止 WEB 应用容器"></a>停止 WEB 应用容器</h4><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker stop quizzical_kirch  quizzical_kirch</code></pre><h4 id="重启WEB应用容器"><a href="#重启WEB应用容器" class="headerlink" title="重启WEB应用容器"></a>重启WEB应用容器</h4><p>已经停止的容器，我们可以使用命令 docker start 来启动。</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker start quizzical_kirchquizzical_kirch</code></pre><p>docker ps -l 查询最后一次创建的容器：</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker ps -l CONTAINER ID   IMAGE             COMMAND           CREATED          STATUS          PORTS                                       NAMESa9f76eee97ee   training/webapp   "python app.py"   10 minutes ago   Up 10 minutes   0.0.0.0:5000->5000/tcp, :::5000->5000/tcp   quizzical_kirch</code></pre><p>正在运行的容器，我们可以使用 <strong>docker restart</strong> 命令来重启。</p><h4 id="移除WEB应用容器"><a href="#移除WEB应用容器" class="headerlink" title="移除WEB应用容器"></a>移除WEB应用容器</h4><p>我们可以使用 docker rm 命令来删除不需要的容器</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker rm quizzical_kirch    quizzical_kirch</code></pre><p>删除容器时，容器必须是停止状态，否则会报如下错误</p><pre class=" language-line-numbers language-shell"><code class="language-line-numbers language-shell">clt@clt-virtual-machine:~$ docker rm quizzical_kirch  Error response from daemon: You cannot remove a running container a9f76eee97ee32e2c6144720f28bc3eee949e0e0ad1caa34d98f0cbb7b83d2ff. Stop the container before attempting removal or force remove</code></pre><p>公众号：写Bug那些事</p><p><a href="https://blog.csdn.net/CltCj?type=blog">我的CSDN</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker介绍及安装</title>
      <link href="/2022/09/04/docker-jie-shao-ji-an-zhuang/"/>
      <url>/2022/09/04/docker-jie-shao-ji-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul><li><p>Docker 是一个开源的应用容器引擎，基于 <a href="https://baike.baidu.com/item/go/953521?fromtitle=Go%E8%AF%AD%E8%A8%80&fromid=3246011&fr=aladdin">Go 语言</a> 并遵从 Apache2.0 协议开源。</p></li><li><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p></li><li><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p></li><li><p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。</p></li><li><p>简单来说：Docker 是一个应用<strong>打包、分发、部署</strong>的工具，你也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要，而普通虚拟机则是一个完整而庞大的系统，包含各种不管你要不要的软件</p><ul><li><p><strong>打包</strong>：就是把你软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包</p></li><li><p><strong>分发</strong>：你可以把你打包好的“安装包”上传到一个镜像仓库，其他人可以非常方便的获取和安装</p></li><li><p><strong>部署</strong>：拿着“安装包”就可以一个命令运行起来你的应用，自动模拟出一摸一样的运行环境，不管是在 Windows&#x2F;Mac&#x2F;Linux。</p></li></ul></li></ul><h3 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h3><ul><li>应用分发、部署，方便传播给他人安装。特别是开源软件和提供私有部署的应用</li><li>应用分发、部署，方便传播给他人安装。特别是开源软件和提供私有部署的应用</li><li>快速安装测试&#x2F;学习软件，用完就丢（类似小程序），不把时间浪费在安装软件上。例如 Redis &#x2F; MongoDB &#x2F; ElasticSearch &#x2F; ELK</li><li>多个版本软件共存，不污染系统，例如 Python2、Python3，Redis4.0，Redis5.0</li></ul><h3 id="Docker-部署的优势"><a href="#Docker-部署的优势" class="headerlink" title="Docker 部署的优势"></a>Docker 部署的优势</h3><p>常规应用开发部署方式：自己在 Windows 上开发、测试 –&gt; 到 Linux 服务器配置运行环境部署。</p><blockquote><p>问题：我机器上跑都没问题，怎么到服务器就各种问题了</p></blockquote><p>用 Docker 开发部署流程：自己在 Windows 上开发、测试 –&gt; 打包为 Docker 镜像（可以理解为软件安装包） –&gt; 各种服务器上只需要一个命令部署好</p><blockquote><p>优点：确保了不同机器上跑都是一致的运行环境，不会出现我机器上跑正常，你机器跑就有问题的情况。</p></blockquote><h3 id="重要概念：镜像、容器"><a href="#重要概念：镜像、容器" class="headerlink" title="重要概念：镜像、容器"></a>重要概念：镜像、容器</h3><p><strong>镜像</strong>：可以理解为软件安装包，可以方便的进行传播和安装。<br><strong>容器</strong>：软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="ubuntu-安装docker"><a href="#ubuntu-安装docker" class="headerlink" title="ubuntu 安装docker"></a>ubuntu 安装docker</h4><p>一、安装docker</p><p>1、安装docker：<code>sudo apt-get install -y docker.io</code></p><p><img src="/2022/09/04/docker-jie-shao-ji-an-zhuang/My_blog/img/image-20220904222102569.png" alt="image-20220904222102569"></p><p>2、启动docker服务：<code>systemctl start docker</code></p><p>3、设置开机启动：<code>systemctl enable docker</code></p><p>4、查看docker状态：<code>systemctl status docker</code></p><p>5、停止docker服务：<code>systemctl stop docker</code></p><p>6、查看docker版本：<code>docker version</code></p><p><img src="/2022/09/04/docker-jie-shao-ji-an-zhuang/My_blog\img\image-20220904222138281.png" alt="image-20220904222138281"></p><p>二、非root用户运行docker</p><p>1、添加docker用户组：<code>sudo groupadd docker</code></p><p>执行以上命令会提示已存在，原因是在安装docker时已自动创建。</p><p>2、将指定用户添加到用户组（username为你的用户名）：<code>sudo gpasswd -a username docker</code></p><p>3、查看是否添加成功：<code>cat /etc/group | grep ^docker</code></p><p>3、重启docker：<code>sudo systemctl restart docker</code></p><p>5、更新用户组：<code>newgrp docker</code></p><p>6、执行docker命令，比如：<code>docker ps -a</code></p><h4 id="windows10"><a href="#windows10" class="headerlink" title="windows10"></a>windows10</h4><p>桌面版：<a href="https://www.docker.com/products/docker-desktop">https://www.docker.com/products/docker-desktop</a><br>服务器版：<a href="https://docs.docker.com/engine/install/#server">https://docs.docker.com/engine/install/#server</a></p><p>安装时出现的错误：</p><p><strong>出现下图错误，点击链接安装最新版本的 WSL2</strong><br><a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi</a></p><p><img src="https://sjwx.easydoc.xyz/46901064/files/kvajwvuw.png" alt="img"></p><h1 id="Docker-镜像加速"><a href="#Docker-镜像加速" class="headerlink" title="Docker 镜像加速"></a>Docker 镜像加速</h1><p>国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：</p><table><thead><tr><th>镜像加速器</th><th>镜像加速器地址</th></tr></thead><tbody><tr><td>Docker 中国官方镜像</td><td><a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></td></tr><tr><td>DaoCloud 镜像站</td><td><a href="http://f1361db2.m.daocloud.io/">http://f1361db2.m.daocloud.io</a></td></tr><tr><td>Azure 中国镜像</td><td><a href="https://dockerhub.azk8s.cn/">https://dockerhub.azk8s.cn</a></td></tr><tr><td>科大镜像站</td><td><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></td></tr><tr><td>阿里云</td><td>https:&#x2F;&#x2F;<your_code>.mirror.aliyuncs.com</your_code></td></tr><tr><td>七牛云</td><td><a href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com</a></td></tr><tr><td>网易云</td><td><a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></td></tr><tr><td>腾讯云</td><td><a href="https://mirror.ccs.tencentyun.com/">https://mirror.ccs.tencentyun.com</a></td></tr></tbody></table><p>当配置某一个加速器地址之后，若发现拉取不到镜像，请切换到另一个加速器地址。国内各大云服务商均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务。</p><p>阿里云镜像获取地址：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors%EF%BC%8C%E7%99%BB%E9%99%86%E5%90%8E%EF%BC%8C%E5%B7%A6%E4%BE%A7%E8%8F%9C%E5%8D%95%E9%80%89%E4%B8%AD%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%99%A8%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%BD%A0%E7%9A%84%E4%B8%93%E5%B1%9E%E5%9C%B0%E5%9D%80%E4%BA%86%EF%BC%9A">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors，登陆后，左侧菜单选中镜像加速器就可以看到你的专属地址了：</a></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/10/02F3AF04-8203-4E3B-A5AF-96973DBE515F.jpg" alt="img"></p><p>对于使用 Windows 10 的系统，在系统右下角托盘 Docker 图标内右键菜单选择 Settings，打开配置窗口后左侧导航菜单选择 Daemon。在 Registrymirrors 一栏中填写加速器地址 <strong><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn/</a></strong> ，之后点击 Apply 保存后 Docker 就会重启并应用配置的镜像地址了。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/10/38507F68-E30F-4CCA-AE9D-9E9EEF60EC83.jpg" alt="img"></p><h3 id="检查加速器是否生效"><a href="#检查加速器是否生效" class="headerlink" title="检查加速器是否生效"></a>检查加速器是否生效</h3><p>检查加速器是否生效配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行 <strong>docker info</strong>，如果从结果中看到了如下内容，说明配置成功。</p><pre class=" language-line-numbers language-cmd"><code class="language-line-numbers language-cmd">$ docker infoRegistry Mirrors:    https://reg-mirror.qiniu.com</code></pre><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>**云服务器(Elastic Compute Service, ECS)**是一种简单高效、安全可靠、处理能力可弹性伸缩的计算服务。</p><p>云服务器管理方式比物理服务器更简单高效，我们无需提前购买昂贵的硬件，即可迅速创建或删除云服务器，云服务器费用一般在几十到几百不等，可以根据我们的需求配置。</p><p>目前市场上的云服务器很多，这里主要介绍以下几家：</p><ul><li><a href="https://www.runoob.com/linux/linux-cloud-server.html#tx">腾讯云</a>：腾讯云目前活动多一些，性价比也高，<a href="https://curl.qcloud.com/tzANIP5i"> <strong>直达链接</strong> </a>。</li><li>更多云服务器参考： <strong><a href="https://c.runoob.com/cloud-server/">https://c.runoob.com/cloud-server/</a></strong></li></ul><blockquote><p><strong>注意：</strong>很多云服务器给新用户提供的优惠力度是最大，基本上都是 1～2 折，建议新注册的用户购买。</p></blockquote><h4 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h4><p><img src="/2022/09/04/docker-jie-shao-ji-an-zhuang/Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220904210025831.png" alt="image-20220904210025831"></p><h3 id="腾讯云服务器使用"><a href="#腾讯云服务器使用" class="headerlink" title="腾讯云服务器使用"></a>腾讯云服务器使用</h3><p>本章节以腾讯云服务器为例。</p><p><strong>1、首先点击下图购买（更多服务器的配置信息见下文）：</strong></p><p><a href="https://curl.qcloud.com/REjETV5p"><img src="https://www.runoob.com/wp-content/uploads/2019/11/ED28C34B-0BF0-4AA3-A95F-2B348B983CEC.jpeg" alt="img"></a></p><p><strong>2、登陆腾讯云控制台，查看已购买的服务器：</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/11/812CFA9E-41F6-4EA2-8044-9FBCAB9C0AAE.jpg" alt="img"></p><p><strong>3、在使用腾讯云服务器前，我们需要先创建一个 SSH 密钥，点击左侧的</strong> <strong>SSH</strong> 密钥（使用密钥登录比密码更安全）：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/11/018E95B9-756E-4B6C-A0A2-CED21B42F25A.jpg" alt="img"></p><p>输入密钥名称，然后点击确定，就会自动生成一个密钥，密钥会自动下载到本地，请保存好下载的密钥，密钥文件名就是你输入的密钥名称。</p><p><strong>4、接着我们勾选已经创建的密钥，点击 *<em>绑定&#x2F;解绑实例*</em> 按钮，弹窗中会出现我们的 ECS 服务器，将其绑定到这个密钥即可：</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/11/963AF776-FE8C-4340-A426-870D962BDC93.jpg" alt="img"></p><p><strong>5、返回实例列表，点击实例右侧的 *<em>登录*</em> 按钮，弹窗中点击立即登录，这是会弹出一个新的浏览器窗口，我们选择密钥登录，密钥文件就是在第三个步骤创建的：</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/11/A23D733A-DA1B-42C9-91E8-12FB84A68400.jpg" alt="img"></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/11/7603BDAC-3103-4379-B0BE-8E669E069AF4.jpg" alt="img"></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/11/D1D8FA9C-4ECD-42A4-B24B-70520F854858.jpg" alt="img"></p><p>当然你可以选择第三方客户端登录（如：SecureCRT），用户名为 ubuntu，其他系统估计略有不同，然后导入对应的 key 即可。</p><p>公众号：写Bug那些事</p><p><a href="https://blog.csdn.net/CltCj?type=blog">我的CSDN</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL 面试常考</title>
      <link href="/2022/09/03/stl-mian-shi-chang-kao/"/>
      <url>/2022/09/03/stl-mian-shi-chang-kao/</url>
      
        <content type="html"><![CDATA[<h4 id="1、请说说-STL-的基本组成部分"><a href="#1、请说说-STL-的基本组成部分" class="headerlink" title="1、请说说 STL 的基本组成部分"></a>1、<strong>请说说 STL 的基本组成部分</strong></h4><ul><li>标准模板库（Standard Template Library,简称STL）简单说，就是一些常用数据结构和算法的模板的集合。广义上讲，STL分为3类：<u>Algorithm（算法）、Container（容器）和Iterator（迭代器）</u>，容器和算法通过迭代器可以进行无缝地连接。详细的说，STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。</li></ul><p><strong>标准模板库STL主要由6大组成部分：</strong></p><p><strong>容器(Container)</strong></p><ul><li>是一种数据结构， 如list, vector, 和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。</li></ul><p><strong>算法（Algorithm）</strong></p><ul><li>是用来操作容器中的数据的模板函数。</li></ul><p><strong>迭代器（Iterator）</strong></p><ul><li>提供了访问容器中对象的方法。</li></ul><p><strong>仿函数（Function object）</strong></p><ul><li>仿函数又称之为函数对象， 其实就是重载了操作符的struct,没有什么特别的地方。</li></ul><p><strong>适配器（Adaptor）</strong></p><ul><li>简单的说就是一种接口类，专门用来修改现有类的接口，提供一中新的接口；或调用现有的函数来实现所需要的功能。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor。</li></ul><p><strong>空间配制器（Allocator）</strong></p><ol><li>为STL提供空间配置的系统。其中主要工作包括两部分：<ol><li>对象的创建与销毁；</li><li>内存的获取与释放。</li></ol></li></ol><h4 id="2、请说说-STL-中常见的容器，并介绍一下实现原理"><a href="#2、请说说-STL-中常见的容器，并介绍一下实现原理" class="headerlink" title="2、请说说 STL 中常见的容器，并介绍一下实现原理"></a>2、<strong>请说说 STL 中常见的容器，并介绍一下实现原理</strong></h4><p>容器可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是模板类，分为顺序容器、关联式容器、容器适配器三种类型，三种类型容器特性分别如下：</p><p>① 顺序容器</p><p>容器并非排序的，元素的插入位置同元素的值无关。包含vector、deque、list，具体实现原理如下：</p><p>（1）vector 头文件</p><p>动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。</p><p>（2）deque 头文件</p><p>双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（仅次于vector）。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。</p><p>（3）list 头文件</p><p>双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。</p><p>② 关联式容器</p><p>元素是排序的；插入任何元素，都按相应的排序规则来确定其位置；在查找时具有非常好的性能；通常以平衡二叉树的方式实现。包含set、multiset、map、multimap，具体实现原理如下：</p><p>（1）set&#x2F;multiset 头文件</p><p>set 即集合。set中不允许相同元素，multiset中允许存在相同元素。</p><p>（2）map&#x2F;multimap 头文件</p><p>map与set的不同在于map中存放的元素有且仅有两个成员变量，一个名为first,另一个名为second, map根据first值对元素从小到大排序，并可快速地根据first来检索元素。</p><p><strong>注意：map和multimap的不同在于是否允许相同first值的元素。</strong></p><p>③ 容器适配器</p><p>封装了一些基本的容器，使之具备了新的函数功能，比如把deque封装一下变为一个具有stack功能的数据结构。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue，具体实现原理如下：</p><p>（1）stack 头文件</p><p>栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最进插入序列的项（栈顶的项）。后进先出。</p><p>（2）queue 头文件</p><p>队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。先进先出。</p><p>（3）priority_queue 头文件</p><p>优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部。最高优先级元素总是第一个出列。</p><h4 id="3、常见容器性质总结？"><a href="#3、常见容器性质总结？" class="headerlink" title="3、常见容器性质总结？"></a>3、<strong>常见容器性质总结？</strong></h4><ol><li>vector 底层数据结构为数组 ，支持快速随机访问</li><li>list 底层数据结构为双向链表，支持快速增删</li><li>deque 底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.它的保存形式如下:[堆1] –&gt; [堆2] –&gt;[堆3] –&gt; …每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.</li><li>stack 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</li><li>queue 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）</li><li>priority_queue 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现</li><li>set 底层数据结构为红黑树，有序，不重复</li><li>multiset 底层数据结构为红黑树，有序，可重复</li><li>map 底层数据结构为红黑树，有序，不重复</li><li>multimap 底层数据结构为红黑树，有序，可重复</li><li>unordered_set 底层数据结构为hash表，无序，不重复</li><li>unordered_multiset 底层数据结构为hash表，无序，可重复</li><li>unordered_map 底层数据结构为hash表，无序，不重复</li><li>unordered_multimap 底层数据结构为hash表，无序，可重复</li></ol><h4 id="4、STL-容器用过哪些，查找的时间复杂度是多少，为什么"><a href="#4、STL-容器用过哪些，查找的时间复杂度是多少，为什么" class="headerlink" title="4、STL 容器用过哪些，查找的时间复杂度是多少，为什么"></a>4、STL 容器用过哪些，查找的时间复杂度是多少，为什么</h4><p>STL中常用的容器有vector、deque、list、map、set、multimap、multiset、unordered_map、unordered_set等。容器底层实现方式及时间复杂度分别如下：</p><ol><li>vector：采用一维数组实现，元素在内存连续存放，不同操作的时间复杂度为：</li></ol><ul><li>插入: O(N)</li><li>查看: O(1)</li><li>删除: O(N)</li></ul><ol start="2"><li>deque：采用双向队列实现，元素在内存连续存放，不同操作的时间复杂度为：</li></ol><ul><li>插入: O(N)</li><li>查看: O(1)删除: O(N)</li></ul><ol start="3"><li>list：采用双向链表实现，元素存放在堆中，不同操作的时间复杂度为：</li></ol><ul><li>插入: O(1)</li><li>查看: O(N)</li><li>删除: O(1)</li></ul><ol start="4"><li>map、set、multimap、multiset：这四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为:</li></ol><ul><li>插入: O(logN)</li><li>查看: O(logN)</li><li>删除: O(logN)</li></ul><h4 id="5、说一下STL每种容器对应的迭代器"><a href="#5、说一下STL每种容器对应的迭代器" class="headerlink" title="5、说一下STL每种容器对应的迭代器"></a>5、<strong>说一下STL每种容器对应的迭代器</strong></h4><ul><li>随机访问迭代器：vector、deque</li><li>双向迭代器：list、(multi)set&#x2F;map</li><li>前向迭代器：unordered_(multi)set&#x2F;map、forward_list</li></ul><h4 id="6、STL中vector的实现"><a href="#6、STL中vector的实现" class="headerlink" title="6、STL中vector的实现"></a>6、<strong>STL中vector的实现</strong></h4><ul><li>vector是一种序列式容器，其数据安排以及操作方式与array非常类似，两者的唯一差别就是对于空间运用的灵活性，众所周知，array占用的是静态空间，一旦配置了就不可以改变大小，如果遇到空间不足的情况还要自行创建更大的空间，并手动将数据拷贝到新的空间中，再把原来的空间释放。vector则使用灵活的动态空间配置，维护一块连续的线性空间，在空间不足时，可以自动扩展空间容纳新元素，做到按需供给。其在扩充空间的过程中仍然需要经历：重新配置空间，移动数据，释放原空间等操作。这里需要说明一下动态扩容的规则：以原大小的两倍配置另外一块较大的空间（或者旧长度+新增元素的个数）vector扩容倍数与平台有关，在Win + VS 下是 1.5倍，在 Linux + GCC 下是 2 倍需要注意的是，频繁对vector调用push_back()对性能是有影响的，这是因为每插入一个元素，如果空间够用的话还能直接插入，若空间不够用，则需要重新配置空间，移动数据，释放原空间等操作，对程序性能会造成一定的影响。</li></ul><h4 id="7、简述-vector-的实现原理"><a href="#7、简述-vector-的实现原理" class="headerlink" title="7、简述 vector 的实现原理"></a>7、<strong>简述 vector 的实现原理</strong></h4><p>vector底层实现原理为一维数组（元素在空间连续存放）。</p><ol><li><p>新增元素</p><ul><li>vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。插入新的数据分在最后插入push_back和通过迭代器在任何位置插入，这里说一下通过迭代器插入，通过迭代器与第一个元素的距离知道要插入的位置，即int index&#x3D;iter-begin()。这个元素后面的所有元素都向后移动一个位置，在空出来的位置上存入新增的元素。</li></ul></li><li><p>删除元素</p><ul><li>删除和新增差不多，也分两种，删除最后一个元素pop_back和通过迭代器删除任意一个元素erase(iter)。通过迭代器删除还是先找到要删除元素的位置，即int index&#x3D;iter-begin();这个位置后面的每个元素都想前移动一个元素的位置。同时我们知道erase不释放内存只初始化成默认值。删除全部元素clear：只是循环调用了erase，所以删除全部元素的时候，不释放内存。内存是在析构函数中释放的。</li></ul></li><li><p>迭代器iteraotr</p><ul><li>迭代器iteraotr是STL的一个重要组成部分,通过iterator可以很方便的存储集合中的元素.STL为每个集合都写了一个迭代器, 迭代器其实是对一个指针的包装,实现一些常用的方法,如++,–,!&#x3D;,&#x3D;&#x3D;,*,-&gt;等,通过这些方法可以找到当前元素或是别的元素. vector是STL集合中比较特殊的一个,因为vector中的每个元素都是连续的,所以在自己实现vector的时候可以用指针代替。</li></ul></li></ol><h4 id="8、STL-中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"><a href="#8、STL-中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？" class="headerlink" title="8、STL 中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"></a>8、<strong>STL 中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？</strong></h4><ul><li><p>size()函数返回的是已用空间大小，capacity()返回的是总空间大小，capacity()-size()则是剩余的可用空间大小。当size()和capacity()相等，说明vector目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长。</p></li><li><p>由于动态增长会引起重新分配内存空间、拷贝原空间、释放原空间，这些过程会降低程序效率。因此，可以使用reserve(n)预先分配一块较大的指定大小的内存空间，这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的，这样便提升了效率。只有当n&gt;capacity()时，调用reserve(n)才会改变vector容量。</p></li><li><p>resize()成员函数改变元素的数目，至于空间的的变化需要看具体情况去分析，如下：</p><ol><li>空的vector对象，size()和capacity()都为0</li><li>当空间大小不足时，新分配的空间大小为原空间大小的2倍。</li><li>使用reserve()预先分配一块内存后，在空间未满的情况下，不会引起重新分配，从而提升了效率。</li><li>当reserve()分配的空间比原空间小时，是不会引起重新分配的。</li><li>resize()函数只改变容器的元素数目，未改变容器大小。</li><li>用reserve(size_type)只是扩大capacity值，这些内存空间可能还是“野”的，如果此时使用“[ ]”来访问，则可能会越界。而resize(size_type new_size)会真正使容器具有new_size个对象。</li></ol></li><li><p>不同的编译器，vector有不同的扩容大小。在vs下是1.5倍，在GCC下是2倍；</p></li><li><p>空间和时间的权衡。简单来说， 空间分配的多，平摊时间复杂度低，但浪费空间也多。</p></li><li><p>使用k&#x3D;2增长因子的问题在于，每次扩展的新尺寸必然刚好大于之前分配的总和，也就是说，之前分配的内存空间不可能被使用。这样对内存不友好，最好把增长因子设为(1, 2)，也就是1-2之间的某个数值。对比可以发现<em><strong>*采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。*</strong></em></p></li></ul><h4 id="9、vector如何释放空间"><a href="#9、vector如何释放空间" class="headerlink" title="9、vector如何释放空间?"></a>9、<strong>vector如何释放空间?</strong></h4><ul><li><p>由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。</p></li><li><p>如果需要空间动态缩小，可以考虑使用deque。如果vector，可以用swap()来帮助你释放内存。</p></li></ul><h4 id="10、vector的增加删除都是怎么做的？"><a href="#10、vector的增加删除都是怎么做的？" class="headerlink" title="10、vector的增加删除都是怎么做的？"></a>10、vector的增加删除都是怎么做的？</h4><p>① 新增元素：vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；</p><p>② 对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了 ；</p><p>③ 初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1；</p><p>④ 不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。</p><p>对比可以发现采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容</p><h4 id="11、STL中list的实现"><a href="#11、STL中list的实现" class="headerlink" title="11、STL中list的实现"></a>11、<strong>STL中list的实现</strong></h4><ul><li>相比于vector的连续线型空间，list显得复杂许多，但是它的好处在于插入或删除都只作用于一个元素空间，因此list对空间的运用是十分精准的，对任何位置元素的插入和删除都是常数时间。list不能保证节点在存储空间中连续存储，也拥有迭代器，迭代器的“++”、“–”操作对于的是指针的操作，list提供的迭代器类型是双向迭代器：Bidirectional iterators。</li><li>list是一个双向链表。list与vector的另一个区别是，在插入和接合操作之后，都不会造成原迭代器失效，而vector可能因为空间重新配置导致迭代器失效。</li><li>list也是一个环形链表，因此只要一个指针便能完整表现整个链表。list中node节点指针始终指向尾端的一个空白节点，因此是一种“前闭后开”的区间结构</li><li>list的空间管理默认采用alloc作为空间配置器，<strong>为了方便的以节点大小为配置单位，还定义一个list_node_allocator函数可一次性配置多个节点空间。</strong></li></ul><h4 id="11、STL中list的实现-1"><a href="#11、STL中list的实现-1" class="headerlink" title="11、STL中list的实现"></a>11、<strong>STL中list的实现</strong></h4><ul><li>相比于vector的连续线型空间，list显得复杂许多，但是它的好处在于插入或删除都只作用于一个元素空间，因此list对空间的运用是十分精准的，对任何位置元素的插入和删除都是常数时间。list不能保证节点在存储空间中连续存储，也拥有迭代器，迭代器的“++”、“–”操作对于的是指针的操作，list提供的迭代器类型是双向迭代器：Bidirectional iterators。</li></ul><p>list节点的结构见如下源码：</p><p>template <class t></class></p><p>struct __list_node{</p><p>  typedef void* void_pointer;</p><p>  void_pointer prev;</p><p>  void_pointer next;</p><p>  T data;</p><p>}</p><p>从源码可看出list显然是一个双向链表。list与vector的另一个区别是，在插入和接合操作之后，都不会造成原迭代器失效，而vector可能因为空间重新配置导致迭代器</p><h4 id="12、STL中迭代器失效的情况有哪些？"><a href="#12、STL中迭代器失效的情况有哪些？" class="headerlink" title="12、STL中迭代器失效的情况有哪些？"></a>12、<strong>STL中迭代器失效的情况有哪些？</strong></h4><p><strong>vector：</strong></p><ul><li><p><strong>插入元素：</strong></p><ul><li>1、尾后插入：size &lt; capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size &#x3D;&#x3D; capacity时，所有迭代器均失效（需要重新分配空间）。</li><li>2、中间插入：中间插入：size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size &#x3D;&#x3D; capacity时，所有迭代器均失效。</li></ul></li><li><p>删除元素：</p><ul><li>尾后删除：只有尾迭代失效。</li><li>中间删除：删除位置之后所有迭代失效。</li></ul></li></ul><p><strong>deque 和 vector 的情况类似</strong></p><p>而 list 双向链表每一个节点内存不连续, 删除节点仅当前迭代器失效,erase返回下一个有效迭代器;</p><p>map&#x2F;se t等关联容器底层是红黑树删除节点不会影响其他节点的迭代器, 使用递增方法获取下一个迭代器 mmp.erase(iter++);</p><p>unordered_(hash)  迭代器意义不大, rehash 之后, 迭代器应该也是全部失效.</p><h4 id="13、说说-vector-和-list-的区别，分别适用于什么场景？"><a href="#13、说说-vector-和-list-的区别，分别适用于什么场景？" class="headerlink" title="13、说说 vector 和 list 的区别，分别适用于什么场景？"></a>13、<strong>说说 vector</strong> 和 list 的区别，分别适用于什么场景？</h4><p><u>vector和list区别在于底层实现机理不同，因而特性和适用场景也有所不同。</u> </p><p><strong>vector：一维数组</strong></p><ul><li>特点：元素在内存连续存放，动态数组，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后内存也不会释放。 </li><li>优点：和数组类似开辟一段连续的空间，并且支持随机访问，所以它的查找效率高其时间复杂度 O(1)。 </li><li>缺点：由于开辟一段连续的空间，所以插入删除会需要对数据进行移动比较麻烦，时间复杂度 O（n），另外当空间不足时还需要进行扩容。</li></ul><p><strong>list：双向链表</strong> </p><ul><li>特点：元素在堆中存放，每个元素都是存放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问。 </li><li>优点：底层实现是循环双链表，当对大量数据进行插入删除时，其时间复杂度O(1)。 </li><li>缺点：底层没有连续的空间，只能通过指针来访问，所以查找数据需要遍历其时间复杂度O（n）， 没有提供[]操作符的重载。</li></ul><p><strong>应用场景</strong> </p><ul><li>vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随机访问，而不在乎插入和删除的效率，使用vector。 </li><li>list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。</li></ul><h4 id="14、C-的-vector-和-list中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？"><a href="#14、C-的-vector-和-list中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？" class="headerlink" title="14、C++ 的 vector 和 list中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？"></a>14、<strong>C++ 的 vector 和 list中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？</strong></h4><ol><li><p>迭代器和指针之间的区别</p><ul><li>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，重载了指针的一些操作符，–&gt;、++、–等。迭代器封装了指针，是一个”可遍历STL（ Standard TemplateLibrary）容器内全部或部分元素”的对象，本质是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</li><li>迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。</li></ul></li><li><p>vector和list特性</p><ul><li>vector特性 动态数组。元素在内存连续存放。随机存取任何元素都在常数时间完成。在尾端增删元素具有较大的性能（大部分情况下是常数时间）。</li><li>list特性 双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。</li></ul></li><li><p>vector增删元素</p><ul><li>对于vector而言，删除某个元素以后，该元素后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。</li></ul></li><li><p>list增删元素</p><ul><li>对于list而言，删除某个元素，只有“指向被删除元素”的那个迭代器失效，其它迭代器不受任何影响。</li></ul></li></ol><h4 id="15、STL-中-vector-与-list-具体是怎么实现的？常见操作的时间复杂度是多少？"><a href="#15、STL-中-vector-与-list-具体是怎么实现的？常见操作的时间复杂度是多少？" class="headerlink" title="15、STL 中 vector 与 list 具体是怎么实现的？常见操作的时间复杂度是多少？"></a>15、<strong>STL</strong> <strong>中</strong> <strong>vector</strong> <strong>与 list 具体是怎么实现的？常见操作的时间复杂度是多少？</strong></h4><ol><li><p>vector （元素在内存连续存放）</p><ul><li>vector是动态数组，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后，内存也不会释放；如果新增大小当前大小时才会重新分配内存。</li></ul></li><li><p>list 双向链表（元素存放在堆中）</p><ul><li>元素存放在堆中，每个元素都是放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点，使得它的**随机存取变得非常没有效率*<em><strong>，因此它没有提供[ ]操作符的重载。但是由于链表的特点，</strong>它可以很有效的支持任意地方的删除和插入操作。</em>*</li><li>*特点：**a. 随机访问不方便 b. 删除插入操作方便</li></ul></li><li><p>常见时间复杂度</p><ul><li>vector插入、查找、删除时间复杂度分别为：O(n)、O(1)、O(n)； </li><li>list插入、查找、删除时间复杂度分别为：O(1)、O(n)O(1)。</li></ul></li></ol><h4 id="16、简述-STL-中的-map-的实现原理"><a href="#16、简述-STL-中的-map-的实现原理" class="headerlink" title="16、简述 STL 中的 map 的实现原理"></a>16、<strong>简述 STL 中的 map 的实现原理</strong></h4><ul><li><p>map是关联式容器，map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。</p></li><li><p>map内部实现了一个红黑树（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。map的特性是所有元素会根据键值进行自动排序。map中所有的元素都是pair，拥有键值(key)和实值(value)两个部分，并且不允许元素有相同的key。</p></li><li><p><u>一旦map的key确定了，那么是无法修改的，但是可以修改这个key对应的value</u>。</p></li><li><p>map的在构造时缺省采用递增排序key，也使用alloc配置器配置空间大小，需要注意的是在插入元素时，调用的是红黑树中的insert_unique()方法，而非insert_euqal()（multimap使用）</p></li><li><p><strong>map的特性如下</strong></p><ol><li>map以RBTree作为底层容器；</li><li>所有元素都是键+值存在；</li><li>不允许键重复所有元素是通过键进行自动排序的；</li><li>map的键是不能修改的，但是其键对应的值是可以修改的。</li></ol></li><li><p><strong>红黑树的特性：</strong></p><ul><li>每个节点不是红色就是黑色</li><li>根结点为黑色</li><li>如果节点为红色，其子节点必为黑</li><li><strong>任一节点至（NULL）树尾端的任何路径，所含的黑节点数量必相同</strong></li></ul></li></ul><h4 id="17、STL中set的实现？"><a href="#17、STL中set的实现？" class="headerlink" title="17、STL中set的实现？"></a>17、<strong>STL中set的实现？</strong></h4><ul><li>STL中的容器可分为序列式容器（sequence）和关联式容器（associative），set属于关联式容器。</li><li>set的特性是，所有元素都会根据元素的值自动被排序（默认升序），set元素的键值就是实值，实值就是键值，set不允许有两个相同的键值。</li><li>set不允许迭代器修改元素的值，其迭代器是一种constance iterators。</li><li>标准的STL set以RB-tree（红黑树）作为底层机制，几乎所有的set操作行为都是转调用RB-tree的操作行为。</li></ul><h4 id="18、请你来说一下-map-和-set-有什么区别，分别又是怎么实现的？"><a href="#18、请你来说一下-map-和-set-有什么区别，分别又是怎么实现的？" class="headerlink" title="18、请你来说一下 map 和 set 有什么区别，分别又是怎么实现的？"></a>18、<strong>请你来说一下 map 和 set 有什么区别，分别又是怎么实现的？</strong></h4><ol><li>set是一种关联式容器，其特性如下：<ul><li>set以RBTree作为底层容器</li><li>所得元素的只有key没有value，value就是key </li><li>不允许出现键值重复</li><li>所有的元素都会被自动排序</li><li>不能通过迭代器来改变set的值，因为set的值就是键，set的迭代器是const的</li></ul></li><li>map和set一样是关联式容器，其特性如下：<ol><li>map以RBTree作为底层容器</li><li>所有元素都是键+值存在</li><li>不允许键重复</li><li>所有元素是通过键进行自动排序的</li><li>map的键是不能修改的，但是其键对应的值是可以修改的</li></ol></li></ol><h4 id="19、STL中的deque的实现"><a href="#19、STL中的deque的实现" class="headerlink" title="19、STL中的deque的实现"></a>19、<strong>STL中的deque的实现</strong></h4><ul><li>vector是单向开口（尾部）的连续线性空间，deque则是一种双向开口的连续线性空间，虽然vector也可以在头尾进行元素操作，但是其头部操作的效率十分低下（主要是涉及到整体的移动）</li></ul><p><img src="https://img2020.cnblogs.com/blog/1657559/202107/1657559-20210728211357818-746549817.png" alt="img"></p><ul><li>deque和vector的最大差异一个是deque运行在常数时间内对头端进行元素操作，二是deque没有容量的概念，它是动态地以分段连续空间组合而成，可以随时增加一段新的空间并链接起来。</li><li>deque虽然也提供随机访问的迭代器，但是其迭代器并不是普通的指针，其复杂程度比vector高很多，因此除非必要，否则一般使用vector而非deque。如果需要对deque排序，可以先将deque中的元素复制到vector中，利用sort对vector排序，再将结果复制回deque</li><li>deque由一段一段的定量连续空间组成，一旦需要增加新的空间，只要配置一段定量连续空间拼接在头部或尾部即可，因此deque的最大任务是如何维护这个整体的连续性</li><li>deque的数据结构如下：</li></ul><p><img src="https://img2020.cnblogs.com/blog/1657559/202107/1657559-20210728212220991-1931832786.png" alt="img"></p><ul><li>从deque的迭代器数据结构可以看出，为了保持与容器联结，迭代器主要包含上述4个元素</li><li>deque迭代器的“++”、“–”操作是远比vector迭代器繁琐，其主要工作在于缓冲区边界，如何从当前缓冲 区跳到另一个缓冲区，当然deque内部在插入元素时，如果map中node数量全部使用完，且node指向的缓 冲区也没有多余的空间，这时会配置新的map（2倍于当前+2的数量）来容纳更多的node，也就是可以指 向更多的缓冲区。在deque删除元素时，也提供了元素的析构和空闲缓冲区空间的释放等机制。</li></ul><h4 id="20、STL中hashtable的实现？"><a href="#20、STL中hashtable的实现？" class="headerlink" title="20、STL中hashtable的实现？"></a>20、<strong>STL中</strong>hashtable的实现？</h4><ul><li>STL中的hashtable，使用vector作为底层容器来构建一个bucket(桶)的聚合体，每一个桶维护一个链表来存储元素。能够设计一个哈希函数，使得每一个元素的关键字与一个值一一对应。</li><li>hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作</li><li>在hashtable设计bucket的数量上，其内置了28个质数[53, 97, 193,…,429496729]，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度），其中每个bucket所维护的linked-list长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置。</li></ul><h4 id="21、STL中stack和queue的实现"><a href="#21、STL中stack和queue的实现" class="headerlink" title="21、STL中stack和queue的实现"></a>21、<strong>STL中stack和queue的实现</strong></h4><p><strong>stack</strong></p><ul><li>stack（栈）是一种先进后出（First In Last Out）的数据结构，只有一个入口和出口，那就是栈顶，除了获取栈顶元素外，没有其他方法可以获取到内部的其他元素，其结构图如下：</li></ul><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml8644\wps8.jpg" alt="img"> </p><ul><li><p>stack这种单向开口的数据结构很容易由双向开口的deque和list形成，只需要根据stack的性质对应移除某些接口即可实现。</p></li><li><p>stack除了默认使用deque作为其底层容器之外，也可以使用双向开口的list，只需要在初始化stack时，将list作为第二个参数即可。由于stack只能操作顶端的元素，因此其内部元素无法被访问，也不提供迭代器。</p></li></ul><p><strong>queue</strong></p><ul><li>queue（队列）是一种先进先出（First In First Out）的数据结构，只有一个入口和一个出口，分别位于最底端和最顶端，出口元素外，没有其他方法可以获取到内部的其他元素，其结构图如下：</li></ul><p><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml8644\wps9.jpg" alt="img"> </p><ul><li>类似的，queue这种“先进先出”的数据结构很容易由双向开口的deque和list形成，只需要根据queue的性质对应移除某些接口即可实现，同样，queue也可以使用list作为底层容器，不具有遍历功能，没有迭代器。</li></ul><h4 id="22、说说-STL-中-map-hashtable-deque-list-的实现原理"><a href="#22、说说-STL-中-map-hashtable-deque-list-的实现原理" class="headerlink" title="22、说说 STL 中 map hashtable deque list 的实现原理"></a>22、<strong>说说 STL</strong> <strong>中 map</strong> <strong>hashtable deque list 的实现原理</strong></h4><p>map、hashtable、deque、list实现机理分别为红黑树、函数映射、双向队列、双向链表，他们的特性分别如下：</p><ol><li><p><strong>map实现原理</strong></p><ul><li>map内部实现了一个红黑树（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。</li></ul></li><li><p><strong>hashtable（也称散列表，直译作哈希表）实现原理</strong></p><ul><li>hashtable采用了函数映射的思想记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。这决定了哈希表特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。</li></ul></li><li><p><strong>deque实现原理</strong></p><ul><li>deque内部实现的是一个双向队列。元素在内存连续存放。随机存取任何元素都在常数时间完成（仅次于vector）。所有适用于vector的操作都适用于deque。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。</li></ul></li><li><p><strong>list实现原理</strong></p><ul><li>list内部实现的是一个双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。无成员函数，给定一个下标i，访问第i个元素的内容，只能从头部挨个遍历到第i个元素。</li></ul></li></ol><h4 id="23、STL中的priority-queue的实现"><a href="#23、STL中的priority-queue的实现" class="headerlink" title="23、STL中的priority_queue的实现"></a>23、<strong>STL中的priority_queue的实现</strong></h4><ul><li>priority_queue，优先队列，是一个拥有权值观念的queue，它跟queue一样是顶部入口，底部出口，在插入元素时，元素并非按照插入次序排列，它会自动根据权值（通常是元素的实值）排列，权值最高，排在最前面，如下图所示。</li></ul><p>​<img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml8644\wps10.jpg" alt="img"> </p><ul><li>默认情况下，priority_queue使用一个max-heap完成，底层容器使用的是一般为vector为底层容器，堆heap为处理规则来管理底层容器实现 。priority_queue的这种实现机制导致其不被归为容器，而是一种容器配接器。</li><li>priority_queue的所有元素，进出都有一定的规则，只有queue顶端的元素（权值最高者），才有机会被外界取用，它没有遍历功能，也不提供迭代器</li></ul><h4 id="24、map插入方式？"><a href="#24、map插入方式？" class="headerlink" title="24、map插入方式？"></a>24、<strong>map</strong>插入方式？</h4><p>① 用insert函数插入pair数据</p><p><code>mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_one&quot;));</code> </p><p>② 用insert函数插入value_type数据</p><p><code>mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;));</code></p><p>③ 在insert函数中使用make_pair()函数</p><p><code>mapStudent.insert(make_pair(1, &quot;student_one&quot;));</code> </p><p>④ 用数组方式插入数据</p><p><code>mapStudent[1] = &quot;student_one&quot;;</code> </p><h4 id="25、STL中unordered-map-hash-map-和map的区别，hash-map如何解决冲突以及扩容"><a href="#25、STL中unordered-map-hash-map-和map的区别，hash-map如何解决冲突以及扩容" class="headerlink" title="25、STL中unordered**_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容 **"></a>25、<strong>STL中</strong>unordered**_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容 **</h4><ol><li>unordered_map和map类似，都是存储的key-value的值，可以通过key快速索引到value。不同的是unordered_map不会根据key的大小进行排序。</li><li>存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的，而map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。</li><li>所以使用时map的key需要定义operator&lt;。而unordered_map需要定义hash_value函数并且重载operator&#x3D;&#x3D;。但是很多系统内置的数据类型都自带这些。</li><li>那么如果是自定义类型，那么就需要自己重载operator&lt;或者hash_value()了。</li><li>如果需要内部元素自动排序，使用map，不需要排序使用unordered_map</li><li>unordered_map的底层实现是hash_table;</li><li>hash_map底层使用的是hash_table，而hash_table使用的开链法进行冲突避免，所有hash_map采用开链法进行冲突解决。</li><li><strong>什么时候扩容：</strong>当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值—即当前数组的长度乘以加载因子的值的时候，就要自动扩容。</li><li>**扩容(resize)**就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。</li></ol><h4 id="26、STL中unordered-map和map的区别和应用场景"><a href="#26、STL中unordered-map和map的区别和应用场景" class="headerlink" title="26、STL中unordered_map和map的区别和应用场景"></a>26、<strong>STL中unordered_map和map的区别和应用场景</strong></h4><ul><li>map支持键值的自动排序，底层机制是红黑树，红黑树的查询和维护时间复杂度均为O(log(n))，但是空间占用比较大，因为每个节点要保持父节点、孩子节点及颜色的信息。</li><li>Unordered_map是C++11新添加的容器，底层机制是哈希表，通过hash函数计算元素位置，其查询时间复杂度O(1)，维护时间和bucket桶所维护的list长度有关，但是建立hash表耗时大。</li><li>从两者底层实现来看，map适用于有序数据的应用场景，unordered_map适用于高效查询的应用场。</li></ul><h4 id="27、说说-map-和-unordered-map-的区别？底层实现"><a href="#27、说说-map-和-unordered-map-的区别？底层实现" class="headerlink" title="27、说说 map 和 unordered_map 的区别？底层实现"></a>27、说说 map 和 unordered_map 的区别？底层实现</h4><ul><li>map和unordered_map的区别在于他们的实现基理不同。</li></ul><ol><li><p>map实现机理</p><ul><li>map内部实现了一个红黑树（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。</li></ul></li><li><p>unordered_map实现机理</p><ul><li>unordered_map内部实现了一个哈希表（也叫散列表），通过把关键码值映射到Hash表中一个位置来访问记录，查找时间复杂度可达O（1），其中在海量数据处理中有着广泛应用。因此，元素的排列顺序是无序的。</li></ul></li></ol><h4 id="28、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"><a href="#28、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？" class="headerlink" title="28、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"></a>28、<strong>vector越界</strong>访问<strong>下标，map越界访问下标？vector删除元素时会不会释放空间？</strong></h4><ul><li><p>① 通过下标访问vector中的元素时会做边界检查，但该处的实现方式要看具体IDE，不同IDE的实现方式不一样，确保不可访问越界地址。</p></li><li><p>② map的下标运算符[]的作用是：将key作为下标去执行查找，并返回相应的值；如果不存在这个key，就将一个具有该key和value的某值插入这个map。</p></li><li><p>③ erase()函数，只能删除内容，不能改变容量大小;</p></li><li><p>④ erase成员函数，它删除了itVect迭代器指向的元素，并且返回要被删除的itVect之后的迭代器，迭代器相当于一个智能指针;</p></li><li><p>⑤ clear()函数，只能清空内容，不能改变容量大小;如果要想在删除内容的同时释放内存，那么你可以选择deque容器。</p></li></ul><h4 id="29、map中-与find的区别？"><a href="#29、map中-与find的区别？" class="headerlink" title="29、map中[]与find的区别？"></a>29、<strong>map中[]与find的区别？</strong></h4><ul><li>map的下标运算符[]的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map。</li><li>map的find函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。</li></ul><h4 id="30、STL中list与queue之间的区别"><a href="#30、STL中list与queue之间的区别" class="headerlink" title="30、STL中list与queue之间的区别"></a>30、<strong>STL中list与queue之间的区别</strong></h4><ul><li>① list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在存储空间中连续存在；</li><li>②list插入操作和接合操作都不会造成原有的list迭代器失效;</li><li>③ list不仅是一个双向链表，而且还是一个环状双向链表，所以它只需要一个指针；</li><li>④ list不像vector那样有可能在空间不足时做重新配置、数据移动的操作，所以插入前的所有迭代器在插入操作之后都仍然有效；</li><li>⑤ deque是一种双向开口的连续线性空间，所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作；</li><li>⑥ deque和vector最大的差异，一在于deque允许常数时间内对起头端进行元素的插入或移除操作，二在于deque没有所谓容量概念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，deque没有所谓的空间保留功能。</li></ul><h4 id="31、set和map的区别，multimap和multiset区别"><a href="#31、set和map的区别，multimap和multiset区别" class="headerlink" title="31、set和map的区别，multimap和multiset区别"></a>31、<strong>set和map的区别，multimap和multiset区别</strong></h4><ul><li>set只提供一种数据类型的接口，但是它会将这一个元素分配到key和value上，而且它的compare_function用的是identity函数，这个函数是输入什么就输出什么，这样就实现了set机制，set的key和value是一样的，它保存的是两份数据，而不是一份数据</li><li>map提供了两种数据类型的接口，分别分配到key和value上，它的compare_function采用的是红黑树的compare_function，它保存的是两份数据</li><li>它们两个的insert都是红黑树的insert_unique()独一无二的插入</li><li>multimap和map唯一的区别就是：multimap调用的是insert_equal()可以重复插入，map调用的是独一无二的插入，set和multiset也一样，只是再插入的时候调用的方法不一样，底层实现都一样。</li></ul><h4 id="32、hashtable中解决冲突的方法？"><a href="#32、hashtable中解决冲突的方法？" class="headerlink" title="32、hashtable中解决冲突的方法？"></a>32、<strong>hashtable中解决冲突的方法？</strong></h4><p><strong>开链法</strong>：每个桶维护一条list，如果哈希函数计算出的桶相同，则按顺序存在这个list中。</p><p><strong>再散列</strong>：发生冲突时使用另一种哈希函数再计算一个地址，直到不冲突</p><p><strong>线性探测</strong>：使用哈希函数计算出的位置如果已经由元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位。</p><p><strong>二次探测</strong>：使用hash函数计算出的位置如果已经有元素占用了，按照1^2、2^2、3^2…的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测</p><p><strong>公共溢出区</strong>：一旦hash函数计算的结果相同，就放入公共溢出区</p><h4 id="33、容器内部删除一个元素"><a href="#33、容器内部删除一个元素" class="headerlink" title="33、容器内部删除一个元素"></a>33、<strong>容器内部删除一个元素</strong></h4><ul><li>① 顺序容器（序列式容器，比如vector、deque）<ul><li>erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；</li></ul></li><li>② 关联容器(关联式容器，比如map、set、multimap、multiset等)<ul><li>erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；</li></ul></li></ul><h4 id="34、STL中hash-map扩容发生什么？"><a href="#34、STL中hash-map扩容发生什么？" class="headerlink" title="34、STL中hash_map扩容发生什么？"></a>34、STL中hash_map扩容发生什么？</h4><ol><li>hash table表格内的元素称为桶（bucket),而由桶所链接的元素称为节点（node),其中存入桶元素的容器为stl本身很重要的一种序列式容器——vector容器。之所以选择vector为存放桶元素的基础容器，主要是因为vector容器本身具有动态扩容能力，无需人工干预。</li><li>向前操作：首先尝试从目前所指的节点出发，前进一个位置（节点），由于节点被安置于list内，所以利用节点的next指针即可轻易完成前进操作，如果目前正巧是list的尾端，就跳至下一个bucket身上，那正是指向下一个list的头部节点。</li></ol><h4 id="35、STL迭代器讲一下"><a href="#35、STL迭代器讲一下" class="headerlink" title="35、STL迭代器讲一下"></a>35、<strong>STL迭代器讲一下</strong></h4><ol><li>Iterator（迭代器）模式又称游标（Cursor）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。 由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展Iterator。</li><li>迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。</li><li>迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的是*运算符与-&gt;运算符，以及++、–等可能需要重载的运算符重载。这和C++中的智能指针很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能。</li><li>最常用的迭代器的相应型别有五种：value type、difference type、pointer、reference、iterator catagoly;</li></ol><h4 id="36、迭代器用过吗？什么时候会失效？"><a href="#36、迭代器用过吗？什么时候会失效？" class="headerlink" title="36、迭代器用过吗？什么时候会失效？"></a>36、<strong>迭代器用过吗？什么时候会失效？</strong></h4><p>用过，常用容器迭代器失效情形如下:</p><ol><li><p>对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。</p></li><li><p>对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。</p></li><li><p>对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。</p></li></ol><h4 id="37、说一下STL中迭代器的作用，有指针为何还要迭代器？"><a href="#37、说一下STL中迭代器的作用，有指针为何还要迭代器？" class="headerlink" title="37、说一下STL中迭代器的作用，有指针为何还要迭代器？"></a>37、<strong>说一下STL中迭代器的作用，有指针为何还要迭代器？</strong></h4><ol><li><p>迭代器的作用</p><ul><li>用于指向顺序容器和关联容器中的元素</li><li>通过迭代器可以读取它指向的元素</li><li>通过非const迭代器还可以修改其指向的元素</li></ul></li><li><p>迭代器和指针的区别</p><ul><li>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，重载了指针的一些操作符，–&gt;、++、–等。迭代器封装了指针，是一个”可遍历STL（ Standard TemplateLibrary）容器内全部或部分元素”的对象，本质是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。</li></ul></li><li><p>迭代器产生的原因</p><ul><li>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</li></ul></li></ol><h4 id="38、说说-STL-迭代器是怎么删除元素的"><a href="#38、说说-STL-迭代器是怎么删除元素的" class="headerlink" title="38、说说 STL 迭代器是怎么删除元素的"></a>38、<strong>说说 STL 迭代器是怎么删除元素的</strong></h4><ol><li><p>对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器；</p></li><li><p>对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可；</p></li><li><p>对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。</p></li></ol><h4 id="39、说说-push-back-和-emplace-back-的区别"><a href="#39、说说-push-back-和-emplace-back-的区别" class="headerlink" title="39、说说 push_back 和 emplace_back 的区别"></a>39、<strong>说说 push_back 和 emplace_back 的区别</strong></h4><ul><li>如果要将一个临时变量push到容器的末尾，push_back()需要先构造临时对象，再将这个对象拷贝到容器的末尾，而emplace_back()则直接在容器的末尾构造对象，这样就省去了拷贝的过程。</li></ul><h4 id="40、说说-STL-容器动态链接可能产生的问题？"><a href="#40、说说-STL-容器动态链接可能产生的问题？" class="headerlink" title="40、说说 STL 容器动态链接可能产生的问题？"></a>40、<strong>说说 STL 容器动态链接可能产生的问题？</strong></h4><ol><li><p>可能产生的问题</p><ul><li>容器是一种动态分配内存空间的一个变量集合类型变量。在一般的程序函数里，局部容器，参数传递容器，参数传递容器的引用，参数传递容器指针都是可以正常运行的，而在动态链接库函数内部使用容器也是没有问题的，但是给动态库函数传递容器的对象本身，则会出现内存堆栈破坏的问题。</li></ul></li><li><p>产生问题的原因</p><ul><li>容器和动态链接库相互支持不够好，动态链接库函数中使用容器时，参数中只能传递容器的引用，并且要保证容器的大小不能超出初始大小，否则导致容器自动重新分配，就会出现内存堆栈破坏问题。</li></ul></li></ol><h4 id="41、说说-STL-中-resize-和-reserve-的区别"><a href="#41、说说-STL-中-resize-和-reserve-的区别" class="headerlink" title="41、说说 STL 中 resize 和 reserve 的区别"></a>41、<strong>说说 STL 中 resize 和 reserve 的区别</strong></h4><ol><li><p>首先必须弄清楚两个概念：</p><ul><li>capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。还不能通过下标等访问，因为此时容器中还没有创建任何对象。</li><li>size：指的是此时容器中实际的元素个数。可以通过下标访问0-(size-1)范围内的对象。</li></ul></li><li><p>resize和reserve区别主要有以下几点：</p><ul><li>resize既分配了空间，也创建了对象；reserve表示容器预留空间，但并不是真正的创建对象，需要通过insert（）或push_back（）等创建对象。</li><li>resize既修改capacity大小，也修改size大小；reserve只修改capacity大小，不修改size大小。</li><li>两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve只带一个参数，表示容器预留的大小。</li></ul></li></ol><p><strong>问题延伸：</strong></p><ul><li>resize 和 reserve 既有差别，也有共同点。两个接口的共同点是它们都保证了vector的空间大小(capacity)最少达到它的参数所指定的大小。下面就他们的细节进行分析。</li><li>为实现resize的语义，resize接口做了两个保证：<ul><li>保证区间[0, new_size)范围内数据有效，如果下标index在此区间内，vector[indext]是合法的；</li><li>保证区间[0, new_size)范围以外数据无效，如果下标index在区间外，vector[indext]是非法的。</li></ul></li><li>reserve只是保证vector的空间大小(capacity)最少达到它的参数所指定的大小n。在区间[0, n)范围内，如果下标是index，vector[index]这种访问有可能是合法的，也有可能是非法的，视具体情况而定。</li></ul><h4 id="42、简单说一下traits技法"><a href="#42、简单说一下traits技法" class="headerlink" title="42、简单说一下traits技法"></a>42、<strong>简单说一下traits技法</strong></h4><p>traits技法利用“内嵌型别“的编程技巧与编译器的template参数推导功能，增强C++未能提供的关于型别认证方面的能力。常用的有iterator_traits和type_traits。</p><p><strong>iterator_traits</strong>：被称为特性萃取机，能够方便的让外界获取以下5种型别：</p><ul><li>value_type：迭代器所指对象的型别</li><li>difference_type：两个迭代器之间的距离</li><li>pointer：迭代器所指向的型别</li><li>reference：迭代器所引用的型别</li><li>iterator_category：一共有5种分别为：<ol><li>input_iterator：istream独有的迭代器。</li><li>output_iterator：ostream独有的迭代器。</li><li>forward_iterator：继承自input_iterator，单向走的迭代器，只能走一个，不能跳。如forward_list、单向list的hashtable</li><li>bidirectional_iterator：继承自forward_iterator，双向走的迭代器，只能走一个，不能跳。如list、rb-tree、双向list的hashtable</li><li>random_access_iterator：继承自bidirectional_iterator，可以跳的迭代器。如array、vector、deque。</li></ol></li></ul><p>公众号：写Bug那些事</p><p><a href="https://blog.csdn.net/CltCj?type=blog">我的CSDN</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试宝典 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础语法</title>
      <link href="/2022/09/03/c-ji-chu-yu-fa/"/>
      <url>/2022/09/03/c-ji-chu-yu-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="一、C-语言基础"><a href="#一、C-语言基础" class="headerlink" title="一、C++语言基础"></a>一、C++语言基础</h3><h4 id="1、main函数的返回值有什么值得考究之处吗？"><a href="#1、main函数的返回值有什么值得考究之处吗？" class="headerlink" title="1、main函数的返回值有什么值得考究之处吗？"></a>1、main函数的返回值有什么值得考究之处吗？</h4><ul><li>程序运行过程入口点main函数，main()函数返回值类型必须是int，这样返回值才能传递给程序激活者（如操作系统）表示程序正常退出。</li><li><code>main(int argc, char **argv)</code> 参数的传递。参数的处理，一般会调用getopt()函数处理，但实践中，这仅仅是一部分，不会经常用到的技能点。</li></ul><h4 id="2、初始化和赋值的区别"><a href="#2、初始化和赋值的区别" class="headerlink" title="2、初始化和赋值的区别"></a>2、初始化和赋值的区别</h4><ul><li><p>对于简单类型来说，初始化和赋值没什么区别</p></li><li><p>对于类和复杂数据类型来说，会调用拷贝构造函数</p></li></ul><h4 id="3、变量声明和定义区别？"><a href="#3、变量声明和定义区别？" class="headerlink" title="3、变量声明和定义区别？"></a>3、变量声明和定义区别？</h4><ul><li>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间，定义要在定义的地方为其分配存储空间。</li><li>相同变量可以在多处声明（外部变量extern），但只能在一处定义。</li></ul><h4 id="4、定义和声明的区别"><a href="#4、定义和声明的区别" class="headerlink" title="4、定义和声明的区别"></a>4、<strong>定义和声明的区别</strong></h4><ul><li>如果是指变量的声明和定义： 从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。</li><li>如果是指函数的声明和定义： 声明：一般在头文件里，对编译器说：这里我有一个函数叫function() 让编译器知道这个函数的存在。 定义：一般在源文件里，具体就是函数的实现过程写明函数体。</li></ul><h4 id="5、strlen和sizeof区别？"><a href="#5、strlen和sizeof区别？" class="headerlink" title="5、strlen和sizeof区别？"></a>5、strlen和sizeof区别？</h4><ul><li>sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</li><li>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\0’的字符串。</li><li>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。</li></ul><h4 id="6、volatile、mutable和explicit关键字的用法"><a href="#6、volatile、mutable和explicit关键字的用法" class="headerlink" title="6、volatile、mutable和explicit关键字的用法"></a>6、volatile、mutable和explicit关键字的用法</h4><p><strong>（1）volatile</strong></p><ul><li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</li><li>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。<strong>多线程中被几个任务共享的变量需要定义为volatile类型。</strong>该关键字的作用是<u>防止优化编译器把变量从内存装入CPU寄存器中。</u></li><li>可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。</li><li>C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。</li><li>volatile 指针和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念</li></ul><p><strong>（2）mutable</strong></p><ul><li>mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置。</li></ul><p><strong>（3）Explicit</strong></p><ul><li><p>explicit关键字用来修饰类的构造函数，<u>被修饰的构造函数的类，不能发生相应的隐式类型转换</u>，只能以显示的方式进行类型转换，注意以下几点：</p><ul><li>explicit 关键字只能用于类内部的构造函数声明上</li><li>explicit 关键字<strong>作用于单个参数</strong>的构造函数</li><li>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</li></ul></li></ul><h4 id="7、形参与实参的区别？"><a href="#7、形参与实参的区别？" class="headerlink" title="7、形参与实参的区别？"></a>7、形参与实参的区别？</h4><ol><li>形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。</li><li>实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。</li><li>实参和形参在数量上，类型上，顺序上应严格一致，否则会发生“类型不匹配”的错误。</li><li>函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。</li><li>当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。</li></ol><h4 id="8、值传递、指针传递、引用传递的区别和效率"><a href="#8、值传递、指针传递、引用传递的区别和效率" class="headerlink" title="8、值传递、指针传递、引用传递的区别和效率"></a>8、值传递、指针传递、引用传递的区别和效率</h4><ul><li>值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象或是大的结构体对象，将耗费一定的时间和空间。（传值）</li><li>指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）</li><li>引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）</li><li>效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。</li></ul><h4 id="9、对象复用的了解，零拷贝的了解"><a href="#9、对象复用的了解，零拷贝的了解" class="headerlink" title="9、对象复用的了解，零拷贝的了解"></a>9、<strong>对象复用的了解，零拷贝的了解</strong></h4><p><strong>对象复用：</strong></p><ul><li><p>对象复用其本质是一种设计模式：Flyweight享元模式</p></li><li><p>通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建对象的开销，节约系统资源。</p></li></ul><p><strong>零拷贝：</strong></p><ul><li>零拷贝就是一种避免CPU将数据从一块存储拷贝到另外一块存储的技术。</li><li>零拷贝技术可以减少数据拷贝和共享总线操作的次数。</li><li>在C++中，vector的一个成员函数emplace_back()很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入到容器尾部，区别在于push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造，效率更高</li></ul><h4 id="10、C-四种强制转换"><a href="#10、C-四种强制转换" class="headerlink" title="10、C++四种强制转换"></a>10、C++四种强制转换</h4><p><strong>reinterpret_cast：</strong><code>reinterpret_cast&lt;type-id&gt;(expression)</code></p><ul><li>type-id必须是一个指针、引用、算术类型、函数指针或成员指针。它可以用于类型之间进行强制转换。</li></ul><p><strong>const_cast：</strong><code>const_cast&lt;type_id&gt;(expression)</code></p><ul><li>该运算符用来修改类型的const或volatile属性。除了const或volatile修饰之外，type_id和expression的类型是一样的。用法如下：<ul><li>常量指针被转化为非常量的指针，并且仍指向原来的对象</li><li>常量引用被转换成非常量的引用，并且仍然指向原来的对象</li><li>const_cast一般用于修改底指针，如const char* p形式</li></ul></li></ul><p><strong>static_cast：</strong><code>static_cast&lt;type_id&gt;(expression)</code></p><ul><li>该运算符把expression转换为type_id类型，但没有运行时类型检查来保证转换的安全性。用法：</li><li>用于类层次结构中基类和派生类之间指针或引用的转换<ul><li>进行上行转换（派生类转换为基类）是安全的</li><li>进行下行转换，由于没有动态类型的检查，所以是不安全的</li></ul></li><li>用于基本数据类型之间的转换，如int转char，这种转换类型的安全性需要开发人员来保证。</li><li>把空指针转换为目标类型的空指针</li><li>把任何类型的表达式转换为void类型</li></ul><p><strong>dynamic_cast：</strong><code>dynamic_cast(expression)</code></p><ul><li>有类型检查，基类向派生类转换比较安全，但派生类转基类不太安全</li><li>该运算符把expression转换成type_id类型的对象。type_id必须是类的指针，类的引用或void*</li><li>如果type_id是类指针类型，那么expression也必须是一个指针，如果type_id是一个引用，那么expression也必须是一个引用</li><li>dynamic_cast运算符可以在执行期间决定真正的类型，也就是说expression必须是多态类型，如果下行转换是安全的，这个运算符会传回适当转型过的指针。如果下行转换不安全，这个运算符会传回空指针</li><li>dynamic_cast主要用于类层次间的上下行转换，还可以用于类之间的交叉转换<ul><li>上行和static_cast一样–安全的</li><li>下行有类型检查的功能，比static_cast安全</li></ul></li></ul><h4 id="11、C-函数调用的压栈的过程"><a href="#11、C-函数调用的压栈的过程" class="headerlink" title="11、C++函数调用的压栈的过程"></a>11、<strong>C++函数调用的压栈的过程</strong></h4><p>函数调用过程：</p><ol><li>栈空间分配存储空间</li><li>从实参的存储空间复制到形参的栈空间</li><li>进行运算<ul><li>形参在函数未调用前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间</li><li>数组作为参数的函数调用方式是地址传递，形参和实参都是指向相同的内存空间，调用完毕之后形参指针被销毁，但是所指向的内存依旧存在，不能也不会被销毁</li><li>当函数有多个返回值时，不能用普通的return方式实现，需要通过传回地址的形式进行，即地址&#x2F;指针传递</li></ul></li></ol><h4 id="12、写C-代码时有一类错误coredump，很常见，你遇到过吗？怎么调式这个错误？"><a href="#12、写C-代码时有一类错误coredump，很常见，你遇到过吗？怎么调式这个错误？" class="headerlink" title="12、写C++代码时有一类错误coredump，很常见，你遇到过吗？怎么调式这个错误？"></a>12、写C++代码时有一类错误coredump，很常见，你遇到过吗？怎么调式这个错误？</h4><ul><li>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成一个叫做core的文件，这个文件会记录运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的对栈调试信息。</li></ul><h4 id="13、C-中将临时变量作为返回值时的处理过程"><a href="#13、C-中将临时变量作为返回值时的处理过程" class="headerlink" title="13、C++中将临时变量作为返回值时的处理过程"></a>13、<strong>C++中将临时变量作为返回值时的处理过程</strong></h4><ul><li>首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，<u>临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了</u></li><li>C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit</li><li><strong>函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系。如果我们需要返回值，一般使用赋值语句就可以了。</strong></li></ul><h4 id="14、如何获得结构成员相对于结构开头的字节偏移量"><a href="#14、如何获得结构成员相对于结构开头的字节偏移量" class="headerlink" title="14、如何获得结构成员相对于结构开头的字节偏移量"></a>14、<strong>如何获得结构成员相对于结构开头的字节偏移量</strong></h4><ul><li>使用&lt;stddef.h&gt;头文件中的，offsetof宏。</li></ul><h4 id="15、静态类型和动态类型，静态绑定和动态绑定的介绍"><a href="#15、静态类型和动态类型，静态绑定和动态绑定的介绍" class="headerlink" title="15、静态类型和动态类型，静态绑定和动态绑定的介绍"></a>15、<strong>静态类型和动态类型，静态绑定和动态绑定的介绍</strong></h4><ul><li>静态类型：对象在声明时采用的类型，在编译期既已确定；</li><li>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</li><li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</li><li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</li></ul><p>静态绑定和动态绑定的区别：</p><ul><li>静态绑定发生在编译期，动态绑定发生在运行期；</li><li>对象的动态类型可以更改，但是静态类型无法更改；</li><li>要想实现动态，必须使用动态绑定；</li><li><strong>在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；</strong></li></ul><h4 id="16、你知道静态绑定和动态绑定吗"><a href="#16、你知道静态绑定和动态绑定吗" class="headerlink" title="16、你知道静态绑定和动态绑定吗?"></a>16、<strong>你知道静态绑定和动态绑定吗?</strong></h4><ul><li>对象的静态类型：对象在声明时采用的类型。是在编译期确定的。</li><li>对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。</li><li>静态绑定：绑定的是对象的静态类型，某特性（比如函数依赖于对象的静态类型，发生在编译期。)</li><li>动态绑定：绑定的是对象的动态类型，某特性（比如函数依赖于对象的动态类型，发生在运行期。)</li></ul><h4 id="17、引用是否能实现动态绑定，为什么可以实现？"><a href="#17、引用是否能实现动态绑定，为什么可以实现？" class="headerlink" title="17、引用是否能实现动态绑定，为什么可以实现？"></a>17、<strong>引用是否能实现动态绑定，为什么可以实现？</strong></h4><p>可以。</p><ul><li>引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。注意只能调用虚函数。需要说明的是<u>虚函数才具有动态绑定</u></li></ul><h4 id="18、类如何实现只能静态分配和只能动态分配"><a href="#18、类如何实现只能静态分配和只能动态分配" class="headerlink" title="18、类如何实现只能静态分配和只能动态分配"></a>18、<strong>类如何实现只能静态分配和只能动态分配</strong></h4><ul><li>前者是把new、delete运算符重载为private属性。后者是把构造、析构函数设为protected属性，再用子类来动态创建</li></ul><p><strong>建立类的对象有两种方式：</strong></p><ol><li>静态建立，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；</li><li>动态建立，A *p &#x3D; new A();动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上，可以将new运算符设为私有。</li></ol><h4 id="19、全局变量和局部变量有什么区别？"><a href="#19、全局变量和局部变量有什么区别？" class="headerlink" title="19、全局变量和局部变量有什么区别？"></a>19、<strong>全局变量和局部变量有什么区别？</strong></h4><ul><li><strong>生命周期不同：</strong>全局变量随主程序创建而创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</li><li><strong>使用方式不同：</strong>通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。</li><li>操作系统和编译器通过内存分配的位置可以区分两者，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面。</li></ul><h4 id="20、怎样判断两个浮点数是否相等？"><a href="#20、怎样判断两个浮点数是否相等？" class="headerlink" title="20、怎样判断两个浮点数是否相等？"></a>20、<strong>怎样判断两个浮点数是否相等？</strong></h4><ul><li>对两个浮点数判断大小和是否相等不能直接用&#x3D;&#x3D;来判断，会出错！明明相等的两个数比较反而是不相等！<strong>对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！</strong>浮点数与0的比较也应该注意。与浮点数的表示方式有关。</li></ul><h4 id="21、nullptr调用成员函数可以吗？为什么？"><a href="#21、nullptr调用成员函数可以吗？为什么？" class="headerlink" title="21、nullptr调用成员函数可以吗？为什么？"></a>21、nullptr调用成员函数可以吗？为什么？</h4><ul><li>能，因为在<strong>编译时对象</strong>就绑定了<strong>函数地址</strong>，和指针空不空没关系。</li></ul><h4 id="22、你知道重载运算符吗？"><a href="#22、你知道重载运算符吗？" class="headerlink" title="22、你知道重载运算符吗？"></a>22、<strong>你知道重载运算符吗？</strong></h4><ol><li>我们只能重载已有的运算符，而无权发明新的运算符；对于一个重载的运算符，其优先级和结合律与内置类型一致才可以；不能改变运算符操作数个数；</li><li>两种重载方式：<u>成员运算符和非成员运算符</u>，成员运算符比非成员运算符少一个参数；下标运算符、箭头运算符必须是成员运算符；</li><li>引入运算符重载，是为了实现类的多态性；</li><li><strong>当重载的运算符是成员函数时，this绑定到左侧运算符对象。成员运算符函数的参数数量比运算符对象的数量少一个；至少含有一个类类型的参数；</strong></li><li>从参数的个数推断到底定义的是哪种运算符，当运算符既是一元运算符又是二元运算符（+，-，*，&amp;）；</li><li>下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本；</li><li>箭头运算符必须是类的成员，解引用通常也是类的成员；重载的箭头运算符必须返回类的指针；</li></ol><h4 id="23、当程序中有函数重载时，函数的匹配原则和顺序是什么？"><a href="#23、当程序中有函数重载时，函数的匹配原则和顺序是什么？" class="headerlink" title="23、当程序中有函数重载时，函数的匹配原则和顺序是什么？"></a>23、<strong>当程序中有函数重载时，函数的匹配原则和顺序是什么？</strong></h4><ol><li>名字查找</li><li>确定候选函数</li><li>寻找最佳匹配</li></ol><h4 id="24、函数调用过程栈的变化，返回值和参数变量哪个先入栈？"><a href="#24、函数调用过程栈的变化，返回值和参数变量哪个先入栈？" class="headerlink" title="24、函数调用过程栈的变化，返回值和参数变量哪个先入栈？"></a>24、<strong>函数调用过程栈的变化，返回值和参数变量哪个先入栈？</strong></h4><ol><li>按照形参顺序相反的顺序压入栈中,<strong>即:从右向左依次把被调函数所需要的参数压入栈</strong>;</li><li>调用者函数使用call指令调用被调函数,并把call指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作隐含在call指令中);</li><li>在被调函数中,被调函数会先保存调用者函数的栈底地址(push ebp),然后再保存调用者函数的栈顶地址,即:当前被调函数的栈底地址(mov ebp,esp)，在被调函数中,从ebp的位置处开始存放被调函数中的局部变量和临时变量,并且这些变量的地址按照定义时的顺序依次减小,即:这些变量的地址是按照栈的延伸方向排列的,先定义的变量先入栈,后定义的变量后入栈;</li></ol><h4 id="25、C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"><a href="#25、C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？" class="headerlink" title="25、C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"></a>25、<strong>C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</strong></h4><ol><li><p><strong>指针参数传递本质上是值传递，它所传递的是一个地址值。</strong></p><ul><li>值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。</li></ul></li><li><p><strong>引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。</strong></p><ul><li>被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。</li></ul></li><li><p><strong>引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。</strong>而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。</p></li><li><p><strong>从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。</strong>指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。</p></li></ol><h4 id="28、你知道printf函数的实现原理是什么吗？"><a href="#28、你知道printf函数的实现原理是什么吗？" class="headerlink" title="28、你知道printf函数的实现原理是什么吗？"></a>28、你知道printf函数的实现原理是什么吗？</h4><ul><li><p>在C&#x2F;C++中，对函数参数的扫描是从后向前的。</p></li><li><p>C&#x2F;C++的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。</p></li><li><p><strong>printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了</strong></p></li></ul><h4 id="30、方法调用的原理（栈，汇编）"><a href="#30、方法调用的原理（栈，汇编）" class="headerlink" title="30、方法调用的原理（栈，汇编）"></a>30、方法调用的原理（栈，汇编）</h4><ul><li>机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。而为单个过程分配的那部分栈称为帧栈；帧栈可以认为是程序栈的一段，它有两个端点，一个标识起始地址，一个标识着结束地址，两个指针结束地址指针esp，开始地址指针ebp;</li><li>由一系列栈帧构成，这些栈帧对应一个过程，而且每一个栈指针+4的位置存储函数返回地址；每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。</li></ul><p><strong>过程实现</strong></p><ol><li>备份原来的帧指针，调整当前的栈帧指针到栈指针位置；</li><li>建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存；</li><li>使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。</li><li>恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了</li><li>释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理。</li><li>恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置。</li><li>弹出返回地址，跳出当前过程，继续执行调用者的代码。</li></ol><p><strong>过程调用和返回指令</strong></p><ol><li>call指令</li><li>leave指令</li><li>ret指令</li></ol><h4 id="31、说一下你理解的-ifdef-endif代表着什么？"><a href="#31、说一下你理解的-ifdef-endif代表着什么？" class="headerlink" title="31、说一下你理解的 ifdef endif代表着什么？"></a>31、说一下你理解的 ifdef endif代表着什么？</h4><ol><li>一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。</li><li>在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。<strong>在头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件重定义。</strong></li></ol><h4 id="32、隐式转换，如何消除隐式转换？"><a href="#32、隐式转换，如何消除隐式转换？" class="headerlink" title="32、隐式转换，如何消除隐式转换？"></a>32、<strong>隐式转换，如何消除隐式转换？</strong></h4><ol><li>C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。<strong>所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。</strong>很多时候用户可能都不知道进行了哪些转换</li><li><strong>C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。通过隐式转换，你可以直接将一个子类的对象使用父类的类型进行返回。</strong>在比如，数值和布尔类型的转换，整数和浮点数的转换等。某些方面来说，隐式转换给C++程序开发者带来了不小的便捷。C++是一门强类型语言，类型的检查是非常严格的。</li><li><strong>基本数据类型</strong> 基本数据类型的转换以取值范围的作为转换基础（保证精度不丢失）。隐式转换发生在从<strong>小-&gt;大</strong>的转换中。比如从char转换为int。从int-&gt;long。自定义对象 子类对象可以隐式的转换为父类对象。</li><li><strong>C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。</strong></li><li>如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换，<strong>关键字explicit只对一个实参的构造函数有效</strong>，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。</li></ol><h4 id="33、C-如何处理多个异常的？"><a href="#33、C-如何处理多个异常的？" class="headerlink" title="33、C++如何处理多个异常的？"></a>33、<strong>C++如何处理多个异常的？</strong></h4><ol><li><p>C++中的异常情况： </p><ul><li><strong>语法错误（编译错误）：比如变量未定义、括号不匹配、关键字拼写错误等等编译器在编译时能发现的错误</strong>，这类错误可以及时被编译器发现，而且可以及时知道出错的位置及原因，方便改正。 </li><li><strong>运行时错误：比如数组下标越界、系统内存不足等等。这类错误不易被程序员发现</strong>，它能通过编译且能进入运行，但运行时会出错，导致程序崩溃。为了有效处理程序运行时错误，C++中引入异常处理机制来解决此问题。</li></ul></li><li><p>C++异常处理机制： 异常处理基本思想：执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理， 而是抛出该异常，让函数的调用者直接或间接处理这个问题。 C++异常处理机制由3个模块组成：try(检查)、throw(抛出)、catch(捕获) 抛出异常的语句格式为：throw 表达式；如果try块中程序段发现了异常则抛出异常。</p></li></ol><h4 id="34、如何在不使用额外空间的情况下，交换两个数？你有几种方法"><a href="#34、如何在不使用额外空间的情况下，交换两个数？你有几种方法" class="headerlink" title="34、如何在不使用额外空间的情况下，交换两个数？你有几种方法"></a>34、<strong>如何在不使用额外空间的情况下，交换两个数？你有几种方法</strong></h4><ol><li>算术</li></ol><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">x = x + y;y = x - y;x = x - y; </code></pre><ol start="2"><li>异或</li></ol><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">x = x^y;// 只能对int,char..y = x^y;x = x^y;x ^= y ^= x;</code></pre><h4 id="35、你知道strcpy和memcpy的区别是什么吗？"><a href="#35、你知道strcpy和memcpy的区别是什么吗？" class="headerlink" title="35、你知道strcpy和memcpy的区别是什么吗？"></a>35、<strong>你知道strcpy和memcpy的区别是什么吗？</strong></h4><ol><li><strong>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容</strong>，例如字符数组、整型、结构体、类等。 </li><li><strong>复制的方法不同。</strong>strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。 </li><li><strong>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</strong></li></ol><h4 id="36、程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？"><a href="#36、程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？" class="headerlink" title="36、程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？"></a>36、程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？</h4><ul><li>参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]，所有的参数在指针</li><li><code>char *</code> 指向的内存中，数组的中元素的个数为 argc 个，第一个参数为程序的名称。</li></ul><h4 id="37、volatile关键字的作用？"><a href="#37、volatile关键字的作用？" class="headerlink" title="37、volatile关键字的作用？"></a>37、volatile关键字的作用？</h4><ul><li><strong>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改</strong>，比如：操作系统、硬件或者其它线程等。<strong>遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</strong></li><li>声明时语法：<code>int volatile vInt;</code> 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</li></ul><p><strong>volatile用在如下的几个地方：</strong></p><ol><li>中断服务程序中修改的供其它程序检测的变量需要加volatile；</li><li>多任务环境下各任务间共享的标志应该加volatile；</li><li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义；</li></ol><h4 id="38、如果有一个空类，它会默认添加哪些函数？"><a href="#38、如果有一个空类，它会默认添加哪些函数？" class="headerlink" title="38、如果有一个空类，它会默认添加哪些函数？"></a>38、<strong>如果有一个空类，它会默认添加哪些函数？</strong></h4><ol><li><p>Empty(); &#x2F;&#x2F; 缺省构造函数&#x2F;&#x2F;</p></li><li><p>Empty( const Empty&amp; ); &#x2F;&#x2F; 拷贝构造函数&#x2F;&#x2F;</p></li><li><p>~Empty(); &#x2F;&#x2F; 析构函数&#x2F;&#x2F;</p></li><li><p>Empty&amp; operator&#x3D;( const Empty&amp; ); &#x2F;&#x2F; 赋值运算符&#x2F;&#x2F;</p></li></ol><h4 id="39、C-中标准库是什么？"><a href="#39、C-中标准库是什么？" class="headerlink" title="39、C++中标准库是什么？"></a>39、<strong>C++中标准库是什么？</strong></h4><p>C++ 标准库可以分为两部分：</p><ul><li><p>标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。</p></li><li><p>面向对象类库： 这个库是类及其相关函数的集合。</p></li><li><p>输入&#x2F;输出 I&#x2F;O、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数</p></li><li><p>标准的 C++ I&#x2F;O 类、String 类、数值类、STL 容器类、STL 算法、STL 函数对象、STL 迭代器、STL 分配器、本地化库、异常处理类、杂项支持库</p></li></ul><h4 id="40、你知道-const-char-与string之间的关系是什么吗？"><a href="#40、你知道-const-char-与string之间的关系是什么吗？" class="headerlink" title="40、你知道*const* char* 与string之间的关系是什么吗？"></a>40、<strong>你知道</strong><em><strong>*const*</strong></em> <strong>char* 与string之间的关系是什么吗？</strong></h4><ul><li><strong>string 是c++标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用const char*给string类初始化</strong></li></ul><h4 id="41、你什么情况用指针当参数，什么时候用引用，为什么？"><a href="#41、你什么情况用指针当参数，什么时候用引用，为什么？" class="headerlink" title="41、你什么情况用指针当参数，什么时候用引用，为什么？"></a>41、<strong>你什么情况用指针当参数，什么时候用引用，为什么？</strong></h4><p>使用引用参数的主要原因有：</p><ul><li><p>程序员能修改调用函数中的数据对象</p></li><li><p>通过传递引用而不是整块数据–对象，可以提高程序的运行速度</p></li></ul><p>一般的原则： 对于使用引用的值而不做修改的函数：</p><ul><li><p>如果数据对象很小，如内置数据类型或者小型结构，则按照值传递；</p></li><li><p>如果数据对象是数组，则使用指针（唯一的选择），并且指针声明为指向const的指针；</p></li><li><p>如果数据对象是较大的结构，则使用const指针或者引用，已提高程序的效率。这样可以节省结构所需的时间和空间；</p></li><li><p><strong>如果数据对象是类对象，则使用const引用（传递类对象参数的标准方式是按照引用传递）；</strong></p></li></ul><p>对于修改函数中数据的函数：</p><ul><li><p>如果数据是内置数据类型，则使用指针</p></li><li><p>如果数据对象是结构，则使用引用或者指针</p></li><li><p>如果数据是类对象，则使用引用</p></li></ul><h4 id="42、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？"><a href="#42、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？" class="headerlink" title="42、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？"></a>42、<strong>在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？</strong></h4><p>对比值传递，引用传参的好处：</p><ol><li><strong>在函数内部可以对此参数进行修改</strong></li><li><strong>提高函数调用和运行的效率</strong>（因为没有了传值和生成副本的时间和空间消耗）</li></ol><p>如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参&#x3D;实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。</p><p>用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。<strong>但是有以下的限制：</strong></p><ol><li><strong>不能返回局部变量的引用。</strong>因为函数返回以后局部变量就会被销毁</li><li><strong>不能返回函数内部new分配的内存的引用。</strong>虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak</li><li><strong>可以返回类成员的引用，但是最好是const。</strong>因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。</li></ol><h4 id="43、怎么快速定位错误出现的地方"><a href="#43、怎么快速定位错误出现的地方" class="headerlink" title="43、怎么快速定位错误出现的地方?"></a>43、怎么快速定位错误出现的地方?</h4><ol><li>如果是简单的错误，可以直接双击错误列表里的错误项或者生成输出的错误信息中带行号的地方就可以让编辑窗口定位到错误的位置上。</li><li>对于复杂的模板错误，最好使用生成输出窗口。</li><li>多数情况下触发错误的位置是最靠后的引用位置。如果这样确定不了错误，就需要先把自己写的代码里的引用位置找出来，然后逐个分析了。</li></ol><h4 id="44、如何设计一个计算仅单个子类的对象个数？"><a href="#44、如何设计一个计算仅单个子类的对象个数？" class="headerlink" title="44、如何设计一个计算仅单个子类的对象个数？"></a>44、<strong>如何设计一个计算仅单个子类的对象个数？</strong></h4><ol><li>为类设计一个static静态变量count作为计数器；</li><li>类定义结束后初始化count;</li><li>在构造函数中对count进行+1;</li><li>设计拷贝构造函数，在进行拷贝构造函数中进行count +1，操作；</li><li>设计复制构造函数，在进行复制函数中对count+1操作；</li><li>在析构函数中对count进行-1；</li></ol><h4 id="45、成员初始化列表会在什么时候用到？它的调用过程是什么？"><a href="#45、成员初始化列表会在什么时候用到？它的调用过程是什么？" class="headerlink" title="45、成员初始化列表会在什么时候用到？它的调用过程是什么？"></a>45、<strong>成员初始化列表会在什么时候用到？它的调用过程是什么？</strong></h4><ol><li>当初始化一个引用成员变量时；</li><li>初始化一个const成员变量时；</li><li>当调用一个基类的构造函数，而构造函数拥有一组参数时；</li><li>当调用一个成员类的构造函数，而他拥有一组参数；</li><li>编译器会一一操作初始化列表，以适当顺序在构造函数之内安插初始化操作，并且在任何显示用户代码前。list中的项目顺序是由类中的成员声明顺序决定的，不是初始化列表中的排列顺序决定的。</li></ol><h4 id="46、你知道回调函数吗？它的作用？"><a href="#46、你知道回调函数吗？它的作用？" class="headerlink" title="46、你知道回调函数吗？它的作用？"></a>46、你知道回调函数吗？它的作用？</h4><ol><li><strong>当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数</strong>；</li><li><strong>回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。</strong>为此，你需要做三件事：<strong>1，声明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；</strong></li><li><strong>回调函数就是一个通过函数指针调用的函数。</strong>如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；</li><li>因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。</li></ol><h4 id="47、成员函数里memset-this-0-sizeof-this-会发生什么"><a href="#47、成员函数里memset-this-0-sizeof-this-会发生什么" class="headerlink" title="47、成员函数里memset(this,0,sizeof(*this))会发生什么"></a>47、<strong>成员函数里memset(this,0,sizeof(*this))会发生什么</strong></h4><ul><li>有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就memset(this, 0, sizeof *this);将整个对象的内存全部置为0。对于这种情形可以很好的工作，但是下面几种情形是不可以这么使用的；<ul><li>类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常；</li><li>类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存。</li></ul></li></ul><h4 id="48、说一说strcpy、sprintf与memcpy这三个函数的不同之处"><a href="#48、说一说strcpy、sprintf与memcpy这三个函数的不同之处" class="headerlink" title="48、说一说strcpy、sprintf与memcpy这三个函数的不同之处"></a>48、<strong>说一说strcpy、sprintf与memcpy这三个函数的不同之处</strong></h4><p><strong>操作对象不同</strong></p><ol><li>strcpy的两个操作对象均为字符串</li><li>sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串</li><li>memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</li></ol><p><strong>执行效率不同</strong></p><ol><li>memcpy最高，strcpy次之，sprintf的效率最低。</li></ol><p><strong>实现功能不同</strong></p><ol><li>strcpy主要实现字符串变量间的拷贝</li><li>sprintf主要实现其他数据类型格式到字符串的转化</li><li>memcpy主要是内存块间的拷贝。</li></ol><h4 id="49、将引用作为函数参数有哪些好处？"><a href="#49、将引用作为函数参数有哪些好处？" class="headerlink" title="49、将引用作为函数参数有哪些好处？"></a>49、<strong>将引用作为函数参数有哪些好处？</strong></h4><ol><li><p>传递引用给函数与传递指针的效果是一样的。</p><ul><li>这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。</li></ul></li><li><p><strong>使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；</strong></p><ul><li>而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；</li><li>如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</li></ul></li><li><p>使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</p></li></ol><h4 id="50、你知道Debug和Release的区别是什么吗？"><a href="#50、你知道Debug和Release的区别是什么吗？" class="headerlink" title="50、你知道Debug和Release的区别是什么吗？"></a>50、<strong>你知道Debug和Release的区别是什么吗？</strong></h4><ol><li>调试版本，包含调试信息，所以容量比Release大很多，并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。Debug模式下生成两个文件，除了.exe或.dll文件外，还有一个.pdb文件，该文件记录了代码中断点等调试信息；</li><li>发布版本，不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。（调试信息可在单独的PDB文件中生成）。Release模式下生成一个文件.exe或.dll文件。</li><li>实际上，Debug 和 Release 并没有本质的界限，他们只是一组编译选项的集合，编译器只是按照预定的选项行动。事实上，我们甚至可以修改这些选项，从而得到优化过的调试版本或是带跟踪语句的发布版本。</li></ol><h4 id="51、strcpy函数和strncpy函数的区别？哪个函数更安全？"><a href="#51、strcpy函数和strncpy函数的区别？哪个函数更安全？" class="headerlink" title="51、strcpy函数和strncpy函数的区别？哪个函数更安全？"></a>51、<strong>strcpy</strong>函数和strncpy函数的区别？哪个函数更安全？</h4><p><code>char* strcpy(char* strDest, const char* strSrc)</code></p><p><code>char *strncpy(char *dest, const char *src, size_t n)</code></p><ul><li><p>strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。</p></li><li><p>strncpy函数：用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。 </p><ul><li>如果目标长&gt;指定长&gt;源长，则将源长全部拷贝到目标长，自动加上’\0’</li><li>如果指定长&lt;源长，则将源长中按指定长度拷贝到目标字符串，不包括’\0’</li><li>如果指定长&gt;目标长，运行时错误</li></ul></li></ul><h4 id="52、模板会写吗？写一个比较大小的模板函数"><a href="#52、模板会写吗？写一个比较大小的模板函数" class="headerlink" title="52、模板会写吗？写一个比较大小的模板函数"></a>52、<strong>模板会写吗？写一个比较大小的模板函数</strong></h4><pre class=" language-line-numbers language-C++"><code class="language-line-numbers language-C++">#include<iostream> using namespace std; template<typename type1,typename type2>//函数模板 type1 Max(type1 a,type2 b) &#123;    return a > b ? a : b; &#125; void main()  &#123;   cout<<"Max = "<<Max(5.5,'a')<<endl; &#125; </code></pre><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMDE4NDUzNg==&mid=2247484003&idx=1&sn=afeb664bf51d596a53a554b82749e511&chksm=97693254a01ebb42fa735294c62fa4771cfa5bbed3961bcb83028dd663c1aff32d81f1af0a76&scene=178&cur_album_id=2521475920096985089#rd">来源公众号：写bug那些事</a></p><p><a href="https://blog.csdn.net/CltCj?type=blog">我的CSDN</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试宝典 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> 基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
